<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<!-- saved from url=(0035)http://shared-ptr.com/sh_insns.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Renesas SH Instruction Set Summary</title><style type="text/css">

body
{
  font-size: 13px;
  background-color: white;
}

/* Compatibility column.  */
div.col_head_1, div.col_cont_1
{
  width: 120px;
  float: left;
  padding-right: 20px;
}

/* Format column.  */
div.col_head_2, div.col_cont_2
{
  width: 220px;
  float: left;
  padding-right: 20px;
}

/* Abstract column.  */
div.col_head_3, div.col_cont_3
{
  width: 320px;
  float: left;
  padding-right: 30px;
}

/* Code column.  */
div.col_head_4, div.col_cont_4
{
  width: 130px;
  float: left;
  padding-right: 20px;
}

/* T Bit / DC Bit column.  */
div.col_head_5, div.col_cont_5
{
  width: 60px;
  float: left;
  padding-right: 20px;
}

/* Instruction Group column.  */
div.col_head_6, div.col_cont_6
{
  width: 100px;
  float: left;
  padding-right: 20px;
}

/* Issue Cycles column.  */
div.col_head_7, div.col_cont_7
{
  width: 100px;
  float: left;
  padding-right: 20px;
}

/* Latency Cycles column.  */
div.col_head_8, div.col_cont_8
{
  width: 100px;
  float: left;
/*  padding-right: 5px; */
}

div.col_cont_1, div.col_cont_2, div.col_cont_3,
div.col_cont_4, div.col_cont_5, div.col_cont_6,
div.col_cont_7, div.col_cont_8
{
  font-family: monospace;
  white-space: pre-wrap;
  font-size: 11px;
}

div.col_cont_1, div.col_cont_6,
div.col_cont_7, div.col_cont_8
{
  font-size: 9px;
}

div.col_cont_1
{
  color: #808080;
}

div.page_head
{
  overflow: hidden;
  padding-top: 8px;
  position: fixed;
  top: 0;
  z-index: 100;

  background-color: white;
}

div.page_head_cont
{
/*  background-color: #00D000; */
  font-size: 10px;
}

div.col_head
{
  padding-right: 5px;
  background-color: #D0D0D0;
  float: left;
}

div.col_cont
{
  overflow: hidden;
  padding-bottom: 5px;
  padding-top: 5px;
  border-top-width: 1px;
  border-top-style: dotted;
}

div.col_cont_note
{
  clear: both;
  padding-top: 15px;
/*  padding-left: 0px; */
/*  padding-left:240px;*/
  width: 720px;
}

div.cpu_cols
{
  font-size: 9px;
  overflow: hidden;
  font-family: monospace;
  color: #808080;
  white-space: pre-wrap;
}

div.main
{
  position: relative;
  top: 0px;
  left: 0px;
}

div.table_header
{
}

p.precode
{
  font-size: 11px;
  font-family: monospace;
}

</style><script language="javascript">

function on_page_load ()
{

  var rules = (document.styleSheets[0].cssRules || document.styleSheets[0].rules);
  var w = 0;

  for (var i = 0; i < rules.length; ++i)
  {
    var r = rules[i];
    if (r.selectorText.indexOf ("col") !== -1
        && r.selectorText.indexOf ("col_cont_note") === -1)
    {
      var w_val = 0;
      if (r.style.width)
	w_val += parseInt (r.style.width, 10);
      if (r.style.paddingLeft)
	w_val += parseInt (r.style.paddingLeft, 10);
      if (r.style.paddingRight)
	w_val += parseInt (r.style.paddingRight, 10);

      if (r.selectorText.indexOf ("col_isa_props") !== -1)
	w_val *= 3;

      w += w_val;
    }
  }

/*
  var w = document.getElementById ("col_head").scrollWidth;
*/
  
  var main_div = document.getElementById ("main");
  main_div.style.width = (w + 0) + "px";

  var page_head_div = document.getElementById ("page_head");
  page_head_div.style.width = (w + 0) + 'px';

  var page_head_div_h = page_head_div.clientHeight + "px";
  main_div.style.top = page_head_div_h;
}

function on_page_unload ()
{
}

function on_mouse_over (div_obj)
{
  div_obj.style.backgroundColor = "#F0F0F0";
}

function on_mouse_out (div_obj)
{
  div_obj.style.backgroundColor = "";
}

var cur_opened = null;

function on_mouse_click (div_obj, event)
{
  if (event.defaultPrevented === true)
    return;

  var e = div_obj.children[8];
  var s = window.getSelection ();
 
 if (!s.isCollapsed)
    return;

  if (e.style.display == 'block')
  {
    e.style.display = 'none';
    cur_opened = null;
  }
  else
  {
    e.style.display = 'block';
    if (cur_opened != null)
      cur_opened.style.display = 'none';
    cur_opened = e;
  }
}

</script>
</head>






<body onload="javascript:on_page_load()" onunload="javascript:on_page_unload()">

<div class="page_head" id="page_head" style="width: 1305px;">

<div class="page_head_cont" id="page_head_cont">

<div style="font-size:20px;float:left">
<b>Renesas SH Instruction Set Summary</b>
</div>

<div style="float:right">
Last updated: Mar  5 2020 21:38:49

</div>
<br>
<div style="float:right">
<a href="mailto:olegendo@gcc.gnu.org?Subject=Renesas%20SH%20Instruction%20Set%20Summary">Contact</a>
<a href="https://github.com/shared-ptr/sh_insns">Page Source</a>
</div>

<br><br>

</div>

<div class="col_head" id="col_head">

  <div class="col_head_1"><b><i>Compatibilty</i></b></div>
  <div class="col_head_2"><b><i>Format</i></b></div>
  <div class="col_head_3"><b><i>Abstract</i></b></div>
  <div class="col_head_4"><b><i>Code</i></b></div>


<div class="col_head_5"><b><i>T Bit<br>DC Bit</i></b>
<div class="cpu_cols"> </div></div>
<div class="col_head_6"><b><i>Instruction Group</i></b>
<div class="cpu_cols">SH1   SH2   SH2E  
SH3   SH3E  DSP   
SH4   SH4A  SH2A  </div></div>
<div class="col_head_7"><b><i>Issue Cycles</i></b>
<div class="cpu_cols">SH1   SH2   SH2E  
SH3   SH3E  DSP   
SH4   SH4A  SH2A  </div></div>
<div class="col_head_8"><b><i>Latency Cycles</i></b>
<div class="cpu_cols">SH1   SH2   SH2E  
SH3   SH3E  DSP   
SH4   SH4A  SH2A  </div></div>
</div></div>
<div class="main" id="main" style="width: 1305px; top: 90px;">
<br><b>Data Transfer Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="background-color: rgb(240, 240, 240);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov	Rm,Rn</div>
<div class="col_cont_3">Rm -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm0011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
MT    MT          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOV (int m, int n)
{
  R[n] = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov	#imm,Rn</div>
<div class="col_cont_3">imm -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">1110nnnniiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    MT          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores immediate data, sign-extended to longword, in general register Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVI (int i, int n)
{
  if ((i &amp; 0x80) == 0)
    R[n] = (0x000000FF &amp; i);
  else
    R[n] = (0xFFFFFF00 | i);

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movi20	#imm20,Rn</div>
<div class="col_cont_3">imm -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0000nnnniiii0000 iiiiiiiiiiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores immediate data that has been sign-extended to longword in general
register Rn.
<br><img src="./Renesas SH Instruction Set Summary_files/movi20.svg" height="140">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVI20 (int i, int n)
{
  if (i &amp; 0x00080000) == 0)
    R[n] = (0x000FFFFF &amp; (long)i);
  else
    R[n] = (0xFFF00000 | (long)i);

  PC += 4;
}

</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movi20s	#imm20,Rn</div>
<div class="col_cont_3">imm &lt;&lt; 8 -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0000nnnniiii0001 iiiiiiiiiiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Shifts immediate data 8 bits to the left and performs sign extension to
longword, then stores the resulting data in general register Rn. Using an OR or
ADD instruction as the next instruction enables a 28-bit absolute address to be
generated.
<br><img src="./Renesas SH Instruction Set Summary_files/movi20s.svg" height="150">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVI20S (int i, int n)
{
  if (i &amp; 0x00080000) == 0)
    R[n] = (0x000FFFFF &amp; (long)i);
  else
    R[n] = (0xFFF00000 | (long)i);

  R[n] &lt;&lt;= 8;
  PC += 4;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mova	@(disp,PC),R0</div>
<div class="col_cont_3">(disp*4) + (PC &amp; 0xFFFFFFFC) + 4 -&gt; R0</div>
<div class="col_cont_4">11000111dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the effective address of the source operand into general
register R0.  The 8-bit displacement is zero-extended and quadrupled.
Consequently, the relative interval from the operand is PC + 1020 bytes.  The PC
is the address four bytes after this instruction, but the lowest two bits of the
PC are fixed at 00.
<br><br>

<i><b>Note</b></i><br>SH1*, SH2*, SH3*:<br>
If this instruction is placed immediately after a delayed branch instruction,
the PC must point to an address specified by (the starting address of the branch
destination) + 2.<br><br>

SH4*:<br>
If this instruction is executed in a delay slot, a slot illegal instruction
exception will be generated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVA (int d)
{
  unsigned int disp;
  disp = (unsigned int)(0x000000FF &amp; d);
  R[0] = (PC &amp; 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	@(disp,PC),Rn</div>
<div class="col_cont_3">(disp*2 + PC + 4) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">1001nnnndddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores immediate data, sign-extended to longword, in general register Rn.
The data is stored from memory address (PC + 4 + displacement * 2).
The 8-bit displacement is multiplied by two after zero-extension, and so the
relative distance from the table is in the range up to PC + 4 + 510 bytes. The
PC value is the address of this instruction.
<br><br>

<i><b>Note</b></i><br>If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWI (int d, int n)
{
  unsigned int disp = (0x000000FF &amp; d);
  R[n] = Read_16 (PC + 4 + (disp &lt;&lt; 1));
  if ((R[n] &amp; 0x8000) == 0)
    R[n] &amp;= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Slot illegal instruction exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	@(disp,PC),Rn</div>
<div class="col_cont_3">(disp*4 + (PC &amp; 0xFFFFFFFC) + 4) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">1101nnnndddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores immediate data, sign-extended to longword, in general register Rn.
The data is stored from memory address (PC + 4 + displacement * 4).
The 8-bit displacement is multiplied by four after zero-extension, and so the
relative distance from the operand is in the range up to PC + 4 + 1020 bytes.
The PC value is the address of this instruction. A value with the lower 2 bits
adjusted to 00 is used in address calculation.
<br><br>

<i><b>Note</b></i><br>If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLI (int d, int n)
{
  unsigned int disp = (0x000000FF &amp; d);
  R[n] = Read_32 ((PC &amp; 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2));
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Slot illegal instruction exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	@Rm,Rn</div>
<div class="col_cont_3">(Rm) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm0000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBL (int m, int n)
{
  R[n] = Read_8 (R[m]);
  if ((R[n] &amp; 0x80) == 0)
    R[n] &amp;= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	@Rm,Rn</div>
<div class="col_cont_3">(Rm) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm0001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWL (int m, int n)
{
  R[n] = Read_16 (R[m]);
  if ((R[n] &amp; 0x8000) == 0)
    R[n] &amp;= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	@Rm,Rn</div>
<div class="col_cont_3">(Rm) -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm0010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLL (int m, int n)
{
  R[n] = Read_32 (R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	Rm,@Rn</div>
<div class="col_cont_3">Rm -&gt; (Rn)</div>
<div class="col_cont_4">0010nnnnmmmm0000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBS (int m, int n)
{
  Write_8 (R[n], R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	Rm,@Rn</div>
<div class="col_cont_3">Rm -&gt; (Rn)</div>
<div class="col_cont_4">0010nnnnmmmm0001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWS (int m, int n)
{
  Write_16 (R[n], R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	Rm,@Rn</div>
<div class="col_cont_3">Rm -&gt; (Rn)</div>
<div class="col_cont_4">0010nnnnmmmm0010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLS (int m, int n)
{
  Write_32 (R[n], R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	@Rm+,Rn</div>
<div class="col_cont_3">(Rm) -&gt; sign extension -&gt; Rn, Rm+1 -&gt; Rm</div>
<div class="col_cont_4">0110nnnnmmmm0100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/2   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBP (int m, int n)
{
  R[n] = Read_8 (R[m]);
  if ((R[n] &amp; 0x80) == 0)
    R[n] &amp;= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  if (n != m)
    R[m] += 1;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	@Rm+,Rn</div>
<div class="col_cont_3">(Rm) -&gt; sign extension -&gt; Rn, Rm+2 -&gt; Rm</div>
<div class="col_cont_4">0110nnnnmmmm0101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/2   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWP (int m, int n)
{
  R[n] = Read_16 (R[m]);
  if ((R[n] &amp; 0x8000) == 0)
    R[n] &amp;= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  if (n != m)
    R[m] += 2;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	@Rm+,Rn</div>
<div class="col_cont_3">(Rm) -&gt; Rn, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0110nnnnmmmm0110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/2   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLP (int m, int n)
{
  R[n] = Read_32 (R[m]);

  if (n != m)
    R[m] += 4;

  PC += 2;
}

</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	Rm,@-Rn</div>
<div class="col_cont_3">Rn-1 -&gt; Rn, Rm -&gt; (Rn)</div>
<div class="col_cont_4">0010nnnnmmmm0100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/1   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBM (int m, int n)
{
  Write_8 (R[n] - 1, R[m]);
  R[n] -= 1;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);" style="">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	Rm,@-Rn</div>
<div class="col_cont_3">Rn-2 -&gt; Rn, Rm -&gt; (Rn)</div>
<div class="col_cont_4">0010nnnnmmmm0101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/1   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWM (int m, int n)
{
  Write_16 (R[n] - 2, R[m]);
  R[n] -= 2;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	Rm,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, Rm -&gt; (Rn)</div>
<div class="col_cont_4">0010nnnnmmmm0110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/1   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLM (int m, int n)
{
  Write_32 (R[n] - 4, R[m]);
  R[n] -= 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.b	@-Rm,R0</div>
<div class="col_cont_3">Rm-1 -&gt; Rm, (Rm) -&gt; sign extension -&gt; R0</div>
<div class="col_cont_4">0100mmmm11001011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVRSBM (int m)
{
  R[m] -= 1;
  R[0] = Read_16 (R[m]);

  if ((R[0] &amp; 0x80) == 0)
    R[0] &amp;= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC+=2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.w	@-Rm,R0</div>
<div class="col_cont_3">Rm-2 -&gt; Rm, (Rm) -&gt; sign extension -&gt; R0</div>
<div class="col_cont_4">0100mmmm11011011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVRSWM (int m)
{
  R[m]-= 2;
  R[0] = Read_16 (R[m]);

  if ((R[0] &amp; 0x8000) == 0)
    R[0] &amp;= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.l	@-Rm,R0</div>
<div class="col_cont_3">Rm-4 -&gt; Rm, (Rm) -&gt; R0</div>
<div class="col_cont_4">0100mmmm11101011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVRSLM (int m)
{
  R[m] -= 4;
  R[0] = Read_32 (R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.b	R0,@Rn+</div>
<div class="col_cont_3">R0 -&gt; (Rn), Rn+1 -&gt; Rn</div>
<div class="col_cont_4">0100nnnn10001011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVRSBP (int n)
{
  Write_8 (R[n], R[0]);
  R[n] += 1;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.w	R0,@Rn+</div>
<div class="col_cont_3">R0 -&gt; (Rn), Rn+2 -&gt; Rn</div>
<div class="col_cont_4">0100nnnn10011011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVRSWP (int n)
{
  Write_16 (R[n], R[0]);
  R[n] += 2;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.l	R0,@Rn+</div>
<div class="col_cont_3">R0 -&gt; (Rn), Rn+4 -&gt; Rn</div>
<div class="col_cont_4">0100nnnn10101011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVRSLP (int n)
{
  Write_32 (R[n], R[0]);
  R[n] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	@(disp,Rm),R0</div>
<div class="col_cont_3">(disp + Rm) -&gt; sign extension -&gt; R0</div>
<div class="col_cont_4">10000100mmmmdddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 4-bit displacement is only zero-extended, so a range up to +15 bytes
can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can
be used instead.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBL4 (int m, int d)
{
  long disp = (0x0000000F &amp; (long)d);
  R[0] = Read_8 (R[m] + disp);

  if ((R[0] &amp; 0x80) == 0)
    R[0] &amp;= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.b	@(disp12,Rm),Rn</div>
<div class="col_cont_3">(disp + Rm) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0011nnnnmmmm0001 0100dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBL12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  R[n] = Read_8 (R[m] + disp);

  if ((R[n] &amp; 0x80) == 0)
    R[n] &amp;= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 4;
}

</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movu.b	@(disp12,Rm),Rn</div>
<div class="col_cont_3">(disp + Rm) -&gt; zero extension -&gt; Rn</div>
<div class="col_cont_4">0011nnnnmmmm0001 1000dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers a source operand to a destination, performing unsigned data transfer.
This instruction is ideal for data access in a structure or the stack.
The loaded data is zero-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBUL12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  R[n] = Read_8 (R[m] + disp);
  R[n] &amp;= 0x000000FF;
  PC += 4;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	@(disp,Rm),R0</div>
<div class="col_cont_3">(disp*2 + Rm) -&gt; sign extension -&gt; R0</div>
<div class="col_cont_4">10000101mmmmdddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 4-bit displacement is multiplied by two after zero-extension, enabling a
range up to +30 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWL4 (int m, int d)
{
  long disp = (0x0000000F &amp; (long)d);
  R[0] = Read_16 (R[m] + (disp &lt;&lt; 1));

  if ((R[0] &amp; 0x8000) == 0)
    R[0] &amp;= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.w	@(disp12,Rm),Rn</div>
<div class="col_cont_3">(disp*2 + Rm) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0011nnnnmmmm0001 0101dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWL12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));

  if ((R[n] &amp; 0x8000) == 0)
    R[n] &amp;= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movu.w	@(disp12,Rm),Rn</div>
<div class="col_cont_3">(disp*2 + Rm) -&gt; zero extension -&gt; Rn</div>
<div class="col_cont_4">0011nnnnmmmm0001 1001dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers a source operand to a destination, performing unsigned data transfer.
This instruction is ideal for data access in a structure or the stack.
The loaded data is zero-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWUL12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));
  R[n] &amp;= 0x0000FFFF;
  PC += 4;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	@(disp,Rm),Rn</div>
<div class="col_cont_3">(disp*4 + Rm) -&gt; Rn</div>
<div class="col_cont_4">0101nnnnmmmmdddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 4-bit displacement is multiplied by four after zero-extension, enabling a
range up to +60 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLL4 (int m, int d, int n)
{
  long disp = (0x0000000F &amp; (long)d);
  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.l	@(disp12,Rm),Rn</div>
<div class="col_cont_3">(disp*4 + Rm) -&gt; Rn</div>
<div class="col_cont_4">0011nnnnmmmm0001 0110dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLL12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	R0,@(disp,Rn)</div>
<div class="col_cont_3">R0 -&gt; (disp + Rn)</div>
<div class="col_cont_4">10000000nnnndddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 4-bit displacement is only zero-extended, so a range up to +15 bytes
can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can
be used instead.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBS4 (int d, int n)
{
  long disp = (0x0000000F &amp; (long)d);
  Write_8 (R[n] + disp, R[0]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.b	Rm,@(disp12,Rn)</div>
<div class="col_cont_3">Rm -&gt; (disp + Rn)</div>
<div class="col_cont_4">0011nnnnmmmm0001 0000dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBS12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  Write_8 (R[n] + disp, R[m]);
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	R0,@(disp,Rn)</div>
<div class="col_cont_3">R0 -&gt; (disp*2 + Rn)</div>
<div class="col_cont_4">10000001nnnndddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 4-bit displacement is multiplied by two after zero-extension, enabling a
range up to +30 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWS4 (int d, int n)
{
  long disp = (0x0000000F &amp; (long)d);
  Write_16 (R[n] + (disp &lt;&lt; 1), R[0]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.w	Rm,@(disp12,Rn)</div>
<div class="col_cont_3">Rm -&gt; (disp*2 + Rn)</div>
<div class="col_cont_4">0011nnnnmmmm0001 0001dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWS12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  Write_16 (R[n] + (disp &lt;&lt; 1), R[m]);
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	Rm,@(disp,Rn)</div>
<div class="col_cont_3">Rm -&gt; (disp*4 + Rn)</div>
<div class="col_cont_4">0001nnnnmmmmdddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 4-bit displacement is multiplied by four after zero-extension, enabling a
range up to +60 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLS4 (int m, int d, int n)
{
  long disp = (0x0000000F &amp; (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mov.l	Rm,@(disp12,Rn)</div>
<div class="col_cont_3">Rm -&gt; (disp*4 + Rn)</div>
<div class="col_cont_4">0011nnnnmmmm0001 0010dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLS12 (int d, int m, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	@(R0,Rm),Rn</div>
<div class="col_cont_3">(R0 + Rm) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0000nnnnmmmm1100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBL0 (int m, int n)
{
  R[n] = Read_8 (R[m] + R[0]);

  if ((R[n] &amp; 0x80) == 0)
    R[n] &amp;= 0x000000FF;
  else R[n] |= 0xFFFFFF00;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	@(R0,Rm),Rn</div>
<div class="col_cont_3">(R0 + Rm) -&gt; sign extension -&gt; Rn</div>
<div class="col_cont_4">0000nnnnmmmm1101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWL0 (int m, int n)
{
  R[n] = Read_16 (R[m] + R[0]);

  if ((R[n] &amp; 0x8000) == 0)
    R[n] &amp;= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	@(R0,Rm),Rn</div>
<div class="col_cont_3">(R0 + Rm) -&gt; Rn</div>
<div class="col_cont_4">0000nnnnmmmm1110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLL0 (int m, int n)
{
  R[n] = Read_32 (R[m] + R[0]);
  PC += 2;
}

</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	Rm,@(R0,Rn)</div>
<div class="col_cont_3">Rm -&gt; (R0 + Rn)</div>
<div class="col_cont_4">0000nnnnmmmm0100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBS0 (int m, int n)
{
  Write_8 (R[n] + R[0], R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	Rm,@(R0,Rn)</div>
<div class="col_cont_3">Rm -&gt; (R0 + Rn)</div>
<div class="col_cont_4">0000nnnnmmmm0101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWS0 (int m, int n)
{
  Write_16 (R[n] + R[0], R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	Rm,@(R0,Rn)</div>
<div class="col_cont_3">Rm -&gt; (R0 + Rn)</div>
<div class="col_cont_4">0000nnnnmmmm0110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLS0 (int m, int n)
{
  Write_32 (R[n] + R[0], R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	@(disp,GBR),R0</div>
<div class="col_cont_3">(disp + GBR) -&gt; sign extension -&gt; R0</div>
<div class="col_cont_4">11000100dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be
specified.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBLG (int d)
{
  unsigned int disp = (0x000000FF &amp; d);
  R[0] = Read_8 (GBR + disp);

  if ((R[0] &amp; 0x80) == 0)
    R[0] &amp;= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	@(disp,GBR),R0</div>
<div class="col_cont_3">(disp*2 + GBR) -&gt; sign extension -&gt; R0</div>
<div class="col_cont_4">11000101dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 8-bit displacement is multiplied by two after zero-extension, enabling a
range up to +510 bytes to be specified.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWLG (int d)
{
  unsigned int disp = (0x000000FF &amp; d);
  R[0] = Read_16 (GBR + (disp &lt;&lt; 1));

  if ((R[0] &amp; 0x8000) == 0)
    R[0] &amp;= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	@(disp,GBR),R0</div>
<div class="col_cont_3">(disp*4 + GBR) -&gt; R0</div>
<div class="col_cont_4">11000110dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 8-bit displacement is multiplied by four after zero-extension, enabling a
range up to +1020 bytes to be specified.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLLG (int d)
{
  unsigned int disp = (0x000000FF &amp; d);
  R[0] = Read_32 (GBR + (disp &lt;&lt; 2));
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.b	R0,@(disp,GBR)</div>
<div class="col_cont_3">R0 -&gt; (disp + GBR)</div>
<div class="col_cont_4">11000000dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be
specified.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVBSG (int d)
{
  unsigned int disp = (0x000000FF &amp; d);
  Write_8 (GBR + disp, R[0]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.w	R0,@(disp,GBR)</div>
<div class="col_cont_3">R0 -&gt; (disp*2 + GBR)</div>
<div class="col_cont_4">11000001dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 8-bit displacement is multiplied by two after zero-extension, enabling a
range up to +510 bytes to be specified.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVWSG (int d)
{
  unsigned int disp = (0x000000FF &amp; d);
  Write_16 (GBR + (disp &lt;&lt; 1), R[0]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mov.l	R0,@(disp,GBR)</div>
<div class="col_cont_3">R0 -&gt; (disp*4 + GBR)</div>
<div class="col_cont_4">11000010dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand to the destination.
The 8-bit displacement is multiplied by four after zero-extension, enabling a
range up to +1020 bytes to be specified.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLSG (int d)
{
  unsigned int disp = (0x000000FF &amp; (long)d);
  Write_32 (GBR + (disp &lt;&lt; 2), R[0]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">movco.l	R0,@Rn</div>
<div class="col_cont_3">LDST -&gt; T
If (T == 1): R0 -&gt; Rn
0 -&gt; LDST</div>
<div class="col_cont_4">0000nnnn01110011</div>
<div class="col_cont_5">LDST
</div>
<div class="col_cont_6">                  
                  
      CO          </div>
<div class="col_cont_7">                  
                  
      1           </div>
<div class="col_cont_8">                  
                  
      1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>MOVCO is used in combination with MOVLI to realize an atomic read-modify-write
operation in a single processor.<br><br>
This instruction copies the value of the LDST flag to the T bit. When the T bit
is set to 1, the value of R0 is stored at the address in Rm. If the T bit is
cleared to 0, the value is not stored at the address in Rm. Finally, the LDST
flag is cleared to 0. Since the LDST flag is cleared by an instruction or
exception, storage by the MOVCO instruction only proceeds when no interrupt or
exception has occurred between the execution of the MOVLI and MOVCO instructions.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVCO (int n)
{
  T = LDST;
  if (T == 1)
    Write_32 (R[n], R[0]);

  LDST = 0;
  PC += 2
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">movli.l	@Rm,R0</div>
<div class="col_cont_3">1 -&gt; LDST
(Rm) -&gt; R0
When interrupt/exception occured: 0 -&gt; LDST</div>
<div class="col_cont_4">0000mmmm01100011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      CO          </div>
<div class="col_cont_7">                  
                  
      1           </div>
<div class="col_cont_8">                  
                  
      1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>MOVLI is used in combination with MOVCO to realize an atomic read-modify-write
operation in a single processor.<br><br>
This instruction sets the LDST flag to 1 and reads the four bytes of data
indicated by Rm into R0. If, however, an interrupt or exception occurs, LDST is
cleared to 0. Storage by the MOVCO instruction only proceeds when the
instruction is executed after the LDST bit has been set by the MOVLI instruction
and not cleared by an interrupt or other exception.  When LDST has been cleared
to 0, the MOVCO instruction clears the T bit and does not proceed with storage.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLINK (int m)
{
  LDST = 1;
  R[0] = Read_32 (R[m]);
  PC += 2
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">movua.l	@Rm,R0</div>
<div class="col_cont_3">(Rm) -&gt; R0
Load non-boundary alignment data</div>
<div class="col_cont_4">0100mmmm10101001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      LS          </div>
<div class="col_cont_7">                  
                  
      2           </div>
<div class="col_cont_8">                  
                  
      2           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Loads the longword of data from the effective address indicated
by the contents of Rm in memory to R0. The address is not restricted to longword
boundaries address (4n).  This instruction allows loading from
non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error
exceptions do not occur when access is to non-longword-boundary addresses
(4n + 1, 4n + 2, and 4n + 3).
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVUAL (int m)
{
  Read_Unaligned_32 (R0, R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error (when the privileged area is accessed from user mode)</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">movua.l	@Rm+,R0</div>
<div class="col_cont_3">(Rm) -&gt; R0, Rm + 4 -&gt; Rm
Load non-boundary alignment data</div>
<div class="col_cont_4">0100mmmm11101001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      LS          </div>
<div class="col_cont_7">                  
                  
      2           </div>
<div class="col_cont_8">                  
                  
      2           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Loads the longword of data from the effective address indicated
by the contents of Rm in memory to R0. The address is not restricted to longword
boundaries address (4n).  This instruction allows loading from
non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error
exceptions do not occur when access is to non-longword-boundary addresses
(4n + 1, 4n + 2, and 4n + 3).
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVUALP (int m)
{
  Read_Unaligned_32 (R0,R[m]);

  if (m != 0)
    R[m] += 4;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error (when the privileged area is accessed from user mode)</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movml.l	Rm,@-R15</div>
<div class="col_cont_3">R15-4 -&gt; R15, Rm -&gt; (R15)
R15-4 -&gt; R15, Rm-1 -&gt; (R15)
...
...
R15 - 4 -&gt; R15, R0 -&gt; (R15)
Note: When Rm = R15, read Rm as PR</div>
<div class="col_cont_4">0100mmmm11110001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1-16  </div>
<div class="col_cont_8">                  
                  
            1-16  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (R0 to Rn/Rm) not exceeding the specified
register number and memory with the contents of R15 as its address.
<br><br>
If R15 is specified, PR is transferred instead of R15. That is, when
nnnn(mmmm) = 1111 is specified, R0 to R14 and PR are the general registers
subject to transfer.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLMML (int m)
{
  for (int i = m; i &gt;= 0; i--)
  {
    if (i == 15)
      Write_32 (R[15] - 4, PR);
    else
      Write_32 (R[15] - 4, R[i]);

    R[15] -= 4;
  }

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movml.l	@R15+,Rn</div>
<div class="col_cont_3">(R15) -&gt; R0, R15+4 -&gt; R15
(R15) -&gt; R1, R15+4 -&gt; R15
...
...
(R15) -&gt; Rn
Note: When Rn = R15, read Rn as PR</div>
<div class="col_cont_4">0100nnnn11110101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1-16  </div>
<div class="col_cont_8">                  
                  
            2-17  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (R0 to Rn/Rm) not exceeding the specified
register number and memory with the contents of R15 as its address.
<br><br>
If R15 is specified, PR is transferred instead of R15. That is, when
nnnn(mmmm) = 1111 is specified, R0 to R14 and PR are the general registers
subject to transfer.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLPML (int n)
{
  for (int i = 0; i &lt;= n; i++)
  {
    if (i == 15)
      PR = Read_32 (R[15]);
    else
      R[i] = Read_32 (R[15]);

    R[15] += 4;
  }

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movmu.l	Rm,@-R15</div>
<div class="col_cont_3">R15-4 -&gt; R15, PR -&gt; (R15)
R15-4 -&gt; R15, R14 -&gt; (R15)
...
...
R15-4 -&gt; R15, Rm -&gt; (R15)
Note: When Rm = R15, read Rm as PR</div>
<div class="col_cont_4">0100mmmm11110000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1-16  </div>
<div class="col_cont_8">                  
                  
            1-16  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (Rn/Rm to R14, PR) not lower than the
specified register number and memory with the contents of R15 as its address.
<br><br>
If R15 is specified, PR is transferred instead of R15.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLMMU (int m)
{
  Write_32 (R[15] - 4, PR);
  R[15] -= 4;

  for (int i = 14; i &gt;= m; i--)
  {
    Write_32 (R[15] - 4, R[i]);
    R[15] -= 4;
  }

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movmu.l	@R15+,Rn</div>
<div class="col_cont_3">(R15) -&gt; Rn, R15+4 -&gt; R15
(R15) -&gt; Rn+1, R15+4 -&gt; R15
...
...
(R15) -&gt; R14, R15+4 -&gt; R15
(R15) -&gt; PR
Note: When Rn = R15, read Rn as PR</div>
<div class="col_cont_4">0100nnnn11110100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1-16  </div>
<div class="col_cont_8">                  
                  
            2-17  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (Rn/Rm to R14, PR) not lower than the
specified register number and memory with the contents of R15 as its address.
<br><br>
If R15 is specified, PR is transferred instead of R15.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVLPMU (int n)
{
  for (int i = n; i &lt;= 14; i++)
  {
    R[i] = Read_32 (R[15]);
    R[15] += 4;
  }

  PR = Read_32 (R[15]);
  R[15] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">movrt	Rn</div>
<div class="col_cont_3">~T -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00111001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Reverses the T bit and then stores the resulting value in general register Rn.
The value of Rn is 0 when T = 1 and 1 when T = 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVRT (int n)
{
  if (T == 1)
    R[n] = 0x00000000;
  else
    R[n] = 0x00000001;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">movt	Rn</div>
<div class="col_cont_3">T -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00101001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the T bit in general register Rn.
The value of Rn is 1 when T = 1 and 0 when T = 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVT (int n)
{
  if (T == 1)
    R[n] = 0x00000001;
  else
    R[n] = 0x00000000;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">nott</div>
<div class="col_cont_3">~T -&gt; T</div>
<div class="col_cont_4">0000000001101000</div>
<div class="col_cont_5">~T
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Inverts the T bit, then stores the resulting value in the T bit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void NOTT (void)
{
  if (T == 1)
    T = 0;
  else
    T = 1;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">swap.b	Rm,Rn</div>
<div class="col_cont_3">Rm -&gt; swap lower 2 bytes -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm1000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Swaps the upper and lower parts of the contents of general register Rm and
stores the result in Rn.
The 8 bits from bit 15 to bit 8 of Rm are swapped with the 8 bits from bit 7 to
bit 0. The upper 16 bits of Rm are transferred directly to the upper 16 bits of
Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SWAPB (int m, int n)
{
  unsigned long temp0, temp1;
  temp0 = R[m] &amp; 0xFFFF0000;
  temp1 = (R[m] &amp; 0x000000FF) &lt;&lt; 8;
  R[n] = (R[m] &amp; 0x0000FF00) &gt;&gt; 8;
  R[n] = R[n] | temp1 | temp0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">swap.w	Rm,Rn</div>
<div class="col_cont_3">Rm -&gt; swap upper/lower words -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm1001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Swaps the upper and lower parts of the contents of general register Rm and
stores the result in Rn.
The 16 bits from bit 31 to bit 16 of Rm are swapped with the 16 bits from bit
15 to bit 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SWAPW (int m, int n)
{
  unsigned long temp;
  temp = (R[m] &gt;&gt; 16) &amp; 0x0000FFFF;
  R[n] = R[m] &lt;&lt; 16;
  R[n] |= temp;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">xtrct	Rm,Rn</div>
<div class="col_cont_3">Rm:Rn middle 32 bits -&gt; Rn</div>
<div class="col_cont_4">0010nnnnmmmm1101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Extracts the middle 32 bits from the 64-bit contents of linked general registers
Rm and Rn, and stores the result in Rn.
<br><img src="./Renesas SH Instruction Set Summary_files/xtrct.svg" height="110">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void XTRCT (int m, int n)
{
  unsigned long high = (R[m] &lt;&lt; 16) &amp; 0xFFFF0000;
  unsigned long low = (R[n] &gt;&gt; 16) &amp; 0x0000FFFF;
  R[n] = high | low;
  PC += 2;
}
</p></pre>

</div></div>
<br><b>Bit Manipulation Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">band.b     #imm3,@disp12,Rn</div>
<div class="col_cont_3">(imm of (disp+Rn)) &amp; T -&gt; T</div>
<div class="col_cont_4">0011nnnn0iii1001 0100dddddddddddd</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs a specified bit in memory at the address indicated by (disp + Rn) with the
T bit, and stores the result in the T bit. The bit number is specified by 3-bit
immediate data. With this instruction, data is read from memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BANDM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;

  if ((T == 0) || (assignbit == 0))
    T = 0;
  else
    T = 1;

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bandnot.b  #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">~(imm of (disp+Rn)) &amp; T -&gt; T</div>
<div class="col_cont_4">0011nnnn0iii1001 1100dddddddddddd</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs the value obtained by inverting a specified bit of memory at the address
indicated by (disp + Rn) with the T bit, and stores the result in the T bit.
The bit number is specified by 3-bit immediate data. With this instruction, data
is read from memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BANDNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;

  if ((T == 1) &amp;&amp; (assignbit == 0))
    T = 1;
  else
    T = 0;

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bclr.b     #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">0 -&gt; (imm of (disp+Rn))</div>
<div class="col_cont_4">0011nnnn0iii1001 0000dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears a specified bit of memory at the address indicated by (disp + Rn).
The bit number is specified by 3-bit immediate data. After data is read from
memory as a byte unit, clearing of the specified bit is executed and the
resulting data is then written to memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BCLRM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  temp &amp;= (~(0x00000001 &lt; <imm)); write_8="" (r[n]="" +="" disp,="" temp);="" pc="" }="" <="" p=""></imm));></p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bclr       #imm3,Rn</div>
<div class="col_cont_3">0 -&gt; imm of Rn</div>
<div class="col_cont_4">10000110nnnn0iii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears a specified bit of the LSB 8 bits of a general register Rn.
The bit number is specified by 3-bit immediate data.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLR (int i, int n)
{
  long imm, temp;
  imm = (0x00000007 &amp; (long)i);
  R[n] &amp;= (~(0x00000001 &lt;&lt; imm));
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bld.b      #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">(imm of (disp+Rn)) -&gt; T</div>
<div class="col_cont_4">0011nnnn0iii1001 0011dddddddddddd</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a specified bit of memory at the address indicated by (disp + Rn) in the
T bit. The bit number is specified by 3-bit immediate data. Data is read from
memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BLDM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;

  if (assignbit == 0)
    T = 0;
  else
    T = 1;

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bld        #imm3,Rn</div>
<div class="col_cont_3">imm of Rn -&gt; T</div>
<div class="col_cont_4">10000111nnnn1iii</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a specified bit of the LSB 8 bits of a general register Rn in the T bit.
The bit number is specified by 3-bit immediate data.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BLD (int i, int n)
{
  long imm, assignbit;
  imm = (0x00000007 &amp; (long)i);
  assignbit = (0x00000001 &lt;&lt; imm) &amp; R[n];

  if (assignbit == 0)
    T = 0;
  else
    T = 1;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bldnot.b   #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">~(imm of (disp+Rn)) -&gt; T</div>
<div class="col_cont_4">0011nnnn0iii1001 1011dddddddddddd</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Inverts a specified bit of memory at the address indicated by (disp + Rn), and
stores the resulting value in the T bit. The bit number is specified by 3-bit
immediate data. Data is read from memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BLDNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;

  if (assignbit == 0)
    T = 1;
  else
    T = 0;

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bor.b      #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">(imm of (disp+Rn)) | T -&gt; T</div>
<div class="col_cont_4">0011nnnn0iii1001 0101dddddddddddd</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ORs a specified bit in memory at the address indicated by (disp + Rn) with the
T bit, and stores the result in the T bit. The bit number is specified by 3-bit
immediate data. Data is read from memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BORM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;

  if ((T == 0) &amp;&amp; (assignbit == 0))
    T = 0;
  else
    T = 1;

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bornot.b   #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">~(imm of (disp+Rn)) | T -&gt; T</div>
<div class="col_cont_4">0011nnnn0iii1001 1101dddddddddddd</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ORs the value obtained by inverting a specified bit of memory at the address
indicated by (disp + Rn) with the T bit, and stores the result in the T bit.
The bit number is specified by 3-bit immediate data. With this instruction,
data is read from memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BORNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;

  if ((T == 1) || (assignbit == 0))
    T = 1;
  else
    T = 0;

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bset.b     #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">1 -&gt; (imm of (disp+Rn))</div>
<div class="col_cont_4">0011nnnn0iii1001 0001dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sets to 1 a specified bit of memory at the address indicated by (disp + Rn).
The bit number is specified by 3-bit immediate data. After data is read from
memory as a byte unit, the specified bit is set to 1, and the resulting data is
then written to memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BSETM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  temp |= (0x00000001 &lt;&lt; imm);
  Write_8 (R[n] + disp, temp);
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bset       #imm3,Rn</div>
<div class="col_cont_3">1 -&gt; imm of Rn</div>
<div class="col_cont_4">10000110nnnn1iii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sets to 1 a specified bit of the LSB 8 bits of a general register Rn. The bit
number is specified by 3-bit immediate data.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BSET (int i, int n)
{
  long imm, temp;
  imm = (0x00000007 &amp; (long)i);
  R[n] |= (0x00000001 &lt;&lt; imm);
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bst.b      #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">T -&gt; (imm of (disp+Rn))</div>
<div class="col_cont_4">0011nnnn0iii1001 0010dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the contents of the T bit to a specified 1-bit location of memory at
the address indicated by (disp + Rn). The bit number is specified by 3-bit
immediate data. After data is read from memory as a byte unit, transfer from the
T bit to the specified bit is executed, and the resulting data is then written
to memory as a byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BSTM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);

  if (T == 0)
    temp &amp;= (~(0x00000001 &lt;&lt; imm));
  else
    temp |= (0x00000001 &lt;&lt; imm);

  Write_8 (R[n] + disp, temp);
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bst        #imm3,Rn</div>
<div class="col_cont_3">T -&gt; imm of Rn</div>
<div class="col_cont_4">10000111nnnn0iii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the contents of the T bit to a specified 1-bit location of the
LSB 8 bits of a general register Rn. The bit number is specified by 3-bit
immediate data.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BST (int i, int n)
{
  long disp, imm;
  disp = (0x00000FFF &amp; (long)d);
  imm = (0x00000007 &amp; (long)i);

  if (T == 0)
    R[n] &amp;= (~(0x00000001 &lt;&lt; imm));
  else
    R[n] |= (0x00000001 &lt;&lt; imm);

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">bxor.b     #imm3,@(disp12,Rn)</div>
<div class="col_cont_3">(imm of (disp+Rn)) ^ T -&gt; T</div>
<div class="col_cont_4">0011nnnn0iii1001 0110dddddddddddd</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Exclusive-ORs a specified bit in memory at the address indicated by (disp + Rn)
with the T bit, and stores the result in the T bit. The bit number is specified
by 3-bit immediate data. With this instruction, data is read from memory as a
byte unit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BXORM (int d, int i, int n)
{
  long disp = (0x00000FFF &amp; (long)d);
  long imm = (0x00000007 &amp; (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;

  if (assignbit == 0)
  {
    if (T == 0)
      T = 0;
    else
      T = 1;
  }
  else
  {
    if (T == 0)
      T = 1;
    else
      T = 0;
  }

  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<br><b>Arithmetic Operation Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">add	Rm,Rn</div>
<div class="col_cont_3">Rn + Rm -&gt; Rn</div>
<div class="col_cont_4">0011nnnnmmmm1100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds together the contents of general registers Rn and Rm and stores the
result in Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ADD (int m, int n)
{
  R[n] += R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">add	#imm,Rn</div>
<div class="col_cont_3">Rn + (sign extension)imm</div>
<div class="col_cont_4">0111nnnniiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds together the contents of general register Rn and the immediate value
and stores the result in Rn.  The 8-bit immediate value is sign-extended to
32 bits, which allows it to be used for immediate subtraction or decrement
operations.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ADDI (int i, int n)
{
  if ((i &amp; 0x80) == 0)
    R[n] += (0x000000FF &amp; (long)i);
  else
    R[n] += (0xFFFFFF00 | (long)i);

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">addc	Rm,Rn</div>
<div class="col_cont_3">Rn + Rm + T -&gt; Rn, carry -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm1110</div>
<div class="col_cont_5">Carry
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds together the contents of general registers Rn and Rm and the T bit, and
stores the result in Rn.  A carry resulting from the operation is reflected in
the T bit.  This instruction can be used to implement additions exceeding 32
bits.

<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ADDC (int m, int n)
{
  unsigned long tmp0, tmp1;
  tmp1 = R[n] + R[m];
  tmp0 = R[n];
  R[n] = tmp1 + T;

  if (tmp0&gt;tmp1)
    T = 1;
  else
    T = 0;

  if (tmp1 &gt; R[n])
    T = 1;

  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">clrt           ! r0:r1 (64 bits) + r2:r3 (64 bits) = r0:r1 (64 bits)
addc  r3,r1    ! Before execution T = 0, r1 = 0x00000001, r3 = 0xFFFFFFFF
               ! After execution T = 1, r1 = 0x00000000
addc  r2,r0    ! Before execution T = 1, r0 = 0x00000000, r2 = 0x00000000
               ! After execution T = 0, r0 = 0x00000001
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">addv	Rm,Rn</div>
<div class="col_cont_3">Rn + Rm -&gt; Rn, overflow -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm1111</div>
<div class="col_cont_5">Overflow
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds together the contents of general registers Rn and Rm and stores the result
in Rn.  If overflow occurs, the T bit is set.

<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ADDV (int m, int n)
{
  long dest, src, ans;

  if ((long)R[n] &gt;= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)R[m] &gt;= 0)
    src = 0;
  else
    src = 1;

  src += dest;
  R[n] += R[m];

  if ((long)R[n] &gt;= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (src == 0 || src == 2)
  {
    if (ans == 1)
      T = 1;
    else
      T = 0;
  }
  else
    T = 0;

  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">addv  r0,r1  ! Before execution: r0 = 0x00000001, r1 = 0x7FFFFFFE, T = 0
             ! After execution:  r1 = 0x7FFFFFFF, T = 0

addv  r0,r1  ! Before execution: r0 = 0x00000002, r1 = 0x7FFFFFFE, T = 0
             ! After execution:  r1 = 0x80000000, T = 1
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/eq	#imm,R0</div>
<div class="col_cont_3">If R0 = (sign extension)imm: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">10001000iiiiiiii</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general register R0 and the sign-extended 8-bit immediate data and sets
the T bit if the values are equal.  If they are not equal the T bit is cleared.
The contents of R0 are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPIM (int i)
{
  long imm;

  if ((i &amp; 0x80) == 0)
    imm = (0x000000FF &amp; (long i));
  else
    imm = (0xFFFFFF00 | (long i));

  if (R[0] == imm)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/eq	Rm,Rn</div>
<div class="col_cont_3">If Rn = Rm: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm0000</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general registers Rn and Rm, and sets the T bit if they are equal.
The contents of Rn and Rm are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPEQ (int m, int n)
{
  if (R[n] == R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/hs	Rm,Rn</div>
<div class="col_cont_3">If Rn &gt;= Rm (unsigned): 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm0010</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general registers Rn and Rm, and sets the T bit if Rn is greater or
equal Rm.  The values for the comparison are interpreted as unsigned integer
values.  The contents of Rn and Rm are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPHI (int m, int n)
{
  if ((unsigned long)R[n] &gt;= (unsigned long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/ge	Rm,Rn</div>
<div class="col_cont_3">If Rn &gt;= Rm (signed): 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm0011</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general registers Rn and Rm, and sets the T bit if Rn is greater or
equal Rm.  The values for the comparison are interpreted as signed integer
values.  The contents of Rn and Rm are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPGE (int m, int n)
{
  if ((long)R[n] &gt;= (long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/hi	Rm,Rn</div>
<div class="col_cont_3">If Rn &gt; Rm (unsigned): 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm0110</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general registers Rn and Rm, and sets the T bit if Rn is greater Rm.
The values for the comparison are interpreted as unsigned integer values.
The contents of Rn and Rm are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPHI (int m, int n)
{
  if ((unsigned long)R[n] &gt; (unsigned long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/gt	Rm,Rn</div>
<div class="col_cont_3">If Rn &gt; Rm (signed): 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm0111</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general registers Rn and Rm, and sets the T bit if Rn is greater Rm.
The values for the comparison are interpreted as signed integer values.
The contents of Rn and Rm are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPGT (int m, int n)
{
  if ((long)R[n] &gt; (long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/pl	Rn</div>
<div class="col_cont_3">If Rn &gt; 0 (signed): 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0100nnnn00010101</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general register Rn and sets the T bit if Rn is greater 0.  The value
in Rn for the comparison is interpreted as signed integer.  The contents of Rn
are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPPL (int n)
{
  if ((long)R[n] &gt; 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/pz	Rn</div>
<div class="col_cont_3">If Rn &gt;= 0 (signed): 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0100nnnn00010001</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general register Rn and sets the T bit if Rn is greater or equal 0.
The value in Rn for the comparison is interpreted as signed integer.  The
contents of Rn are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPPZ (int n)
{
  if ((long)R[n] &gt;= 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">cmp/str	Rm,Rn</div>
<div class="col_cont_3">If Rn and Rm have an equal byte: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0010nnnnmmmm1100</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Compares general registers Rn and Rm, and sets the T bit if any of the 4 bytes
in Rn are equal to the corresponding byte in Rm. The contents of Rn and Rm are
not changed.
<br><br>

<i><b>Note</b></i><br>This instruction can be used to speed up some string operations such as
finding the string length of a zero terminated string or string matching.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CMPSTR (int m, int n)
{
  unsigned long temp;
  long HH, HL, LH, LL;
  temp = R[n] ^ R[m];
  HH = (temp &amp; 0xFF000000) &gt;&gt; 24;
  HL = (temp &amp; 0x00FF0000) &gt;&gt; 16;
  LH = (temp &amp; 0x0000FF00) &gt;&gt; 8;
  LL = temp &amp; 0x000000FF;
  HH = HH &amp;&amp; HL &amp;&amp; LH &amp;&amp; LL;

  if (HH == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">cmp/str  r2,r3    ! r2 = "ABCD", r3 = "XYCZ"
bt       target   ! T = 1, so branch is taken.
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">clips.b	Rn</div>
<div class="col_cont_3">If Rn &gt; 0x0000007F: 0x0000007F -&gt; Rn, 1 -&gt; CS
If Rn &lt; 0xFFFFFF80: 0xFFFFFF80 -&gt; Rn, 1 -&gt; CS</div>
<div class="col_cont_4">0100nnnn10010001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Determines saturation. Signed data is used with this instruction. The saturation
upper-limit value is stored in general register Rn if the contents of Rn exceed
the saturation upper-limit value, or the saturation lower-limit value is stored
in Rn if the contents of Rn are less than the saturation lower-limit value, and
the CS bit is set to 1.
The saturation upper-limit value is 0x0000007F (127).
The saturation lower-limit value is 0xFFFFFF80 (-128).
<br><br>

<i><b>Note</b></i><br>The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value or are not less than the saturation
lower-limit value.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLIPSB (int n)
{
  if (R[n] &gt; 0x0000007F)
  {
    R[n] = 0x0000007F;
    CS = 1;
  }
  else if (R[n] &lt; 0xFFFFFF80)
  {
    R[n] = 0xFFFFFF80;
    CS = 1;
  }

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">clips.w	Rn</div>
<div class="col_cont_3">If Rn &gt; 0x00007FFF: 0x00007FFF -&gt; Rn, 1 -&gt; CS
If Rn &lt; 0xFFFF8000: 0xFFFF8000 -&gt; Rn, 1 -&gt; CS</div>
<div class="col_cont_4">0100nnnn10010101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Determines saturation. Signed data is used with this instruction. The saturation
upper-limit value is stored in general register Rn if the contents of Rn exceed
the saturation upper-limit value, or the saturation lower-limit value is stored
in Rn if the contents of Rn are less than the saturation lower-limit value, and
the CS bit is set to 1.
The saturation upper-limit value is 0x00007FFF (32767).
The saturation lower-limit value is 0xFFFF8000 (-32768).
<br><br>

<i><b>Note</b></i><br>The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value or are not less than the saturation
lower-limit value.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLIPSW (int n)
{
  if (R[n] &gt; 0x00007FFF)
  {
    R[n] = 0x00007FFF;
    CS = 1;
  }
  else if (R[n] &lt; 0xFFFF8000)
  {
    R[n] = 0xFFFF8000;
    CS = 1;
  }

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">clipu.b	Rn</div>
<div class="col_cont_3">If Rn &gt; 0x000000FF: 0x000000FF -&gt; Rn, 1 -&gt; CS</div>
<div class="col_cont_4">0100nnnn10000001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Determines saturation. Unsigned data is used with this instruction. If the
contents of general register Rn exceed the saturation value, the saturation
value is stored in Rn and the CS bit is set to 1.
The saturation value is 0x000000FF (255).
<br><br>

<i><b>Note</b></i><br>The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLIPUB (int n)
{
  if (R[n] &gt; 0x000000FF)
  {
    R[n] = 0x000000FF;
    CS = 1;
  }

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">clipu.w	Rn</div>
<div class="col_cont_3">If Rn &gt; 0x0000FFFF: 0x0000FFFF -&gt; Rn, 1 -&gt; CS</div>
<div class="col_cont_4">0100nnnn10000101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Determines saturation. Unsigned data is used with this instruction. If the
contents of general register Rn exceed the saturation value, the saturation
value is stored in Rn and the CS bit is set to 1.
The saturation value is 0x0000FFFF (65535).
<br><br>

<i><b>Note</b></i><br>The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLIPUW (int n)
{
  if (R[n] &gt; 0x0000FFFF)
  {
    R[n] = 0x0000FFFF;
    CS = 1;
  }

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">div0s	Rm,Rn</div>
<div class="col_cont_3">MSB of Rn -&gt; Q, MSB of Rm -&gt; M, M ^ Q -&gt; T</div>
<div class="col_cont_4">0010nnnnmmmm0111</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs initial settings for signed division. This instruction is followed by
a DIV1 instruction that executes 1-digit division, for example, and repeated
division steps are executed to find the quotient. See the description of the
DIV1 instruction for details.
<br><br>

<i><b>Note</b></i><br>This instruction can also be used to compare the signs of Rm and Rn.  If the
signs of Rm and Rn are equal, T will be set to 0.  If the signs of Rm and Rn
are not equal, T will be set to 1.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DIV0S (int m, int n)
{
  if ((R[n] &amp; 0x80000000) == 0)
    Q = 0;
  else
    Q = 1;

  if ((R[m] &amp; 0x80000000) == 0)
    M = 0;
  else
    M = 1;

  T = ! (M == Q);
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">div0u</div>
<div class="col_cont_3">0 -&gt; M, 0 -&gt; Q, 0 -&gt; T</div>
<div class="col_cont_4">0000000000011001</div>
<div class="col_cont_5">0
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs initial settings for unsigned division. This instruction is followed by
a DIV1 instruction that executes 1-digit division, for example, and repeated
division steps are executed to find the quotient. See the description of the
DIV1 instruction for details.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DIV0U (void)
{
  M = Q = T = 0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">div1	Rm,Rn</div>
<div class="col_cont_3">1-step division (Rn / Rm)</div>
<div class="col_cont_4">0011nnnnmmmm0100</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs 1-digit division (1-step division) of the 32-bit contents of general
register Rn (dividend) by the contents of Rm (divisor).
The quotient is obtained by repeated execution of this instruction alone or in
combination with other instructions. The specified registers and the M, Q, and
T bits must not be modified during these repeated executions.
<br><br>
In 1-step division, the dividend is shifted 1 bit to the left, the divisor is
subtracted from this, and the quotient bit is reflected in the Q bit according
to whether the result is positive or negative.
<br><br>
Detection of division by zero or overflow is not provided. Check for division by
zero and overflow division before executing the division. A remainder operation
is not provided. Find the remainder by finding the product of the divisor and
the obtained quotient, and subtracting this value from the dividend:
<br>
<center><code>remainder = dividend - (divisor * quotient)</code></center>
<br>
Initial settings should first be made with the DIV0S or DIV0U instruction. DIV1
is executed once for each bit of the divisor. If a quotient of more than 17
bits is required, place an ROTCL instruction before the DIV1 instruction. See
the examples for details of the division sequence.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DIV1 (int m, int n)
{
  unsigned long tmp0, tmp2;
  unsigned char old_q, tmp1;

  old_q = Q;
  Q = (0x80000000 &amp; R[n]) != 0;
  tmp2 = R[m];
  R[n] &lt;&lt;= 1;
  R[n] |= (unsigned long)T;

  if (old_q == 0)
  {
    if (M == 0)
    {
      tmp0 = R[n];
      R[n] -= tmp2;
      tmp1 = R[n] &gt; tmp0;

      if (Q == 0)
        Q = tmp1;
      else if (Q == 1)
        Q = tmp1 == 0;
    }

    else if (M == 1)
    {
      tmp0 = R[n];
      R[n] += tmp2;
      tmp1 = R[n] &lt; tmp0;

      if (Q == 0)
        Q = tmp1 == 0;
      else if (Q == 1)
        Q = tmp1;
    }
  }

  else if (old_q == 1)
  {
    if (M == 0)
    {
      tmp0 = R[n];
      R[n] += tmp2;
      tmp1 = R[n] &lt; tmp0;

      if (Q == 0)
        Q = tmp1;
      else if (Q == 1)
        Q = tmp1 == 0;
    }

    else if (M == 1)
    {
       tmp0 = R[n];
       R[n] -= tmp2;
       tmp1 = R[n] &gt; tmp0;

       if (Q == 0)
         Q = tmp1 == 0;
       else if (Q == 1)
         Q = tmp1;
    }
  }

  T = (Q == M);
  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">! r1 (32 bits) / r0 (16 bits) = r1 (16 bits)  (unsigned)

shll16  r0        ! Set divisor in upper 16 bits, clear lower 16 bits to 0

tst     r0,r0     ! Check for division by zero
bt      zero_div

cmp/hs  r0,r1     ! Check for overflow
bt      over_div

div0u             ! Flag initialization

.rept 16 
div1    r0,r1     ! Repeat 16 times
.endr

rotcl   r1 
extu.w  r1,r1     ! r1 = quotient

- - - - - - - - - - - - - - - - 

! r1:r2 (64 bits) / r0 (32 bits) = r2 (32 bits)  (unsigned)

tst     r0,r0     ! Check for division by zero
bt      zero_div

cmp/hs  r0,r1     ! Check for overflow
bt      over_div

div0u             ! Flag initialization

.rept 32
rotcl   r2        ! Repeat 32 times
div1    r0,r1
.endr

rotcl   r2        ! r2 = quotient

- - - - - - - - - - - - - - - - 

! r1 (16 bits) / r0 (16 bits) = r1 (16 bits)  (signed)

shll16  r0        ! Set divisor in upper 16 bits, clear lower 16 bits to 0
exts.w  r1,r1     ! Dividend sign-extended to 32 bits
mov     #0,r2
mov     r1,r3 
rotcl   r3 
subc    r2,r1     ! If dividend is negative, subtract 1
div0s   r0,r1     ! Flag initialization

.rept 16
div1    r0,r1     ! Repeat 16 times
.endr

exts.w  r1,r1 
rotcl   r1        ! r1 = quotient (one's complement notation)
addc    r2,r1     ! If MSB of quotient is 1, add 1 to convert to two's complement notation
exts.w  r1,r1     ! r1 = quotient (two's complement notation)

- - - - - - - - - - - - - - - - 

! r2 (32 bits) / r0 (32 bits) = r2 (32 bits)  (signed)

mov     r2,r3 
rotcl   r3 
subc    r1,r1     ! Dividend sign-extended to 64 bits (r1:r2)
mov     #0,r3
subc    r3,r2     ! If dividend is negative, subtract 1 to convert to one's complement notation
div0s   r0,r1     ! Flag initialization

.rept 32
rotcl   r2        ! Repeat 32 times
div1    r0,r1
.endr

rotcl   r2        ! r2 = quotient (one's complement notation)
addc    r3,r2     ! If MSB of quotient is 1, add 1 to convert to two's complement notation
                  ! r2 = quotient (two's complement notation)

- - - - - - - - - - - - - - - - 
! r4 (8 bits) / r5 (8 bits) = r0 (8 bits)  (unsigned)

extu.b  r4,r4     ! Optional, not needed if value is known to be zero extended.
extu.b  r5,r5     ! Optional, not needed if value is known to be zero extended.
shll8   r5
div0u

.rept 8
div1    r5,r4     ! Repeat 8 times
.endr

rotcl   r4
extu.b  r4,r0
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">divs	R0,Rn</div>
<div class="col_cont_3">Signed, Rn / R0 -&gt; Rn
32 / 32 -&gt; 32 bits</div>
<div class="col_cont_4">0100nnnn10010100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            36    </div>
<div class="col_cont_8">                  
                  
            36    </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Executes division of the 32-bit contents of a general register Rn (dividend) by
the contents of R0 (divisor). This instruction executes signed division and
finds the quotient only. A remainder operation is not provided. To obtain the
remainder, find the product of the divisor and the obtained quotient, and
subtract this value from the dividend. The sign of the remainder will be the
same as that of the dividend.
<br><br>

<i><b>Note</b></i><br>An overflow exception will occur if the negative maximum value (0x00000000) is
divided by -1. If division by zero is performed a division by zero exception
will occur.
<br><br>
If an interrupt is generated while this instruction is being executed, execution
will be halted. The return address will be the start address of this instruction,
and this instruction will be re-executed.  This avoids increased interrupt
latency.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DIVS (int n)
{
  R[n] = R[n] / R[0];
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Overflow exception</li>
<li>Division by zero exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">divu	R0,Rn</div>
<div class="col_cont_3">Unsigned, Rn / R0 -&gt; Rn
32 / 32 -&gt; 32 bits</div>
<div class="col_cont_4">0100nnnn10000100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            36    </div>
<div class="col_cont_8">                  
                  
            36    </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Executes division of the 32-bit contents of a general register Rn (dividend) by
the contents of R0 (divisor). This instruction executes unsigned division and
finds the quotient only. A remainder operation is not provided. To obtain the
remainder, find the product of the divisor and the obtained quotient, and
subtract this value from the dividend.
<br><br>

<i><b>Note</b></i><br>A division by zero exception will occur if division by zero is performed.
<br><br>
If an interrupt is generated while this instruction is being executed, execution
will be halted. The return address will be the start address of this instruction,
and this instruction will be re-executed.  This avoids increased interrupt
latency.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DIVU (int n)
{
  R[n]= (unsigned long)R[n] / (unsigned long)R[0];
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Division by zero exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">dmuls.l	Rm,Rn</div>
<div class="col_cont_3">Signed, Rn * Rm -&gt; MACH:MACL
32 * 32 -&gt; 64 bits</div>
<div class="col_cont_4">0011nnnnmmmm1101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">      2           
2                 
2     1     2     </div>
<div class="col_cont_8">      2-4         
2-5               
4/4   2     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs 32-bit multiplication of the contents of general register Rn by the
contents of Rm, and stores the 64-bit result in the MACH and MACL registers.
The multiplication is performed as a signed arithmetic operation.
<br><br>

<i><b>Note</b></i><br>On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DMULS (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;
  long tempm, tempn, fnLmL;

  tempn = (long)R[n];
  tempm = (long)R[m];

  if (tempn &lt; 0)
    tempn = 0 - tempn;

  if (tempm &lt; 0)
    tempm = 0 - tempm;

  if ((long)(R[n] ^ R[m]) &lt; 0)
    fnLmL = -1;
  else
    fnLmL = 0;

  temp1 = (unsigned long)tempn;
  temp2 = (unsigned long)tempm;

  RnL = temp1 &amp; 0x0000FFFF;
  RnH = (temp1 &gt;&gt; 16) &amp; 0x0000FFFF;

  RmL = temp2 &amp; 0x0000FFFF;
  RmH = (temp2 &gt;&gt; 16) &amp; 0x0000FFFF;

  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0;
  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) &amp; 0xFFFF0000;
  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) &amp; 0x0000FFFF) + temp3;

  if (fnLmL &lt; 0)
  {
    Res2 = ~Res2;
    if (Res0 == 0)
      Res2++;
    else
      Res0 = (~Res0) + 1;
  }

  MACH = Res2;
  MACL = Res0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">dmulu.l	Rm,Rn</div>
<div class="col_cont_3">Unsigned, Rn * Rm -&gt; MACH:MACL
32 * 32 -&gt; 64 bits</div>
<div class="col_cont_4">0011nnnnmmmm0101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">      2           
2                 
2     1     2     </div>
<div class="col_cont_8">      2-4         
2-5               
4/4   2     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs 32-bit multiplication of the contents of general register Rn by the
contents of Rm, and stores the 64-bit result in the MACH and MACL registers.
The multiplication is performed as an unsigned arithmetic operation.
<br><br>

<i><b>Note</b></i><br>On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DMULU (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;

  RnL = R[n] &amp; 0x0000FFFF;
  RnH = (R[n] &gt;&gt; 16) &amp; 0x0000FFFF;

  RmL = R[m] &amp; 0x0000FFFF;
  RmH = (R[m] &gt;&gt; 16) &amp; 0x0000FFFF;

  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0
  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) &amp; 0xFFFF0000;
  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) &amp; 0x0000FFFF) + temp3;

  MACH = Res2;
  MACL = Res0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">dt	Rn</div>
<div class="col_cont_3">Rn-1 -&gt; Rn
If Rn = 0: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0100nnnn00010000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">      1           
1                 
1     1     1     </div>
<div class="col_cont_8">      1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Decrements the contents of general register Rn by 1 and compares the result
with zero. If the result is zero, the T bit is set to 1.
If the result is nonzero, the T bit is cleared to 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void DT (int n)
{
  R[n]--;

  if (R[n] == 0)
    T = 1;
  else T = 0;

  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">    mov   #4,r4      ! Set loop count
loop:
    add   r0,r1
    dt    r5         ! Decrement r5 value and check for 0.
    bf    loop       ! if T = 0 branch to loop
                     ! (in this example, 4 loop iterations are executed)
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">exts.b	Rm,Rn</div>
<div class="col_cont_3">Rm sign-extended from byte -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm1110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sign-extends the contents of general register Rm and stores the result in Rn.
The value of Rm bit 7 is transferred to Rn bits 8 to 31.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void EXTSB (int m, int n)
{
  R[n] = R[m];

  if ((R[m] &amp; 0x00000080) == 0)
    R[n] &amp; = 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">exts.w	Rm,Rn</div>
<div class="col_cont_3">Rm sign-extended from word -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm1111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sign-extends the contents of general register Rm and stores the result in Rn.
The value of Rm bit 15 is transferred to Rn bits 16 to 31.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void EXTSW (int m, int n)
{
  R[n] = R[m];

  if ((R[m] &amp; 0x00008000) == 0)
    R[n] &amp; = 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">extu.b	Rm,Rn</div>
<div class="col_cont_3">Rm zero-extended from byte -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm1100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Zero-extends the contents of general register Rm and stores the result in Rn.
0 is transferred to Rn bits 8 to 31.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void EXTUB (int m, int n)
{
  R[n] = R[m];
  R[n] &amp;= 0x000000FF;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">extu.w	Rm,Rn</div>
<div class="col_cont_3">Rm zero-extended from word -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm1101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Zero-extends the contents of general register Rm and stores the result in Rn.
0 is transferred to Rn bits 16 to 31.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void EXTUW (int m, int n)
{
  R[n] = R[m];
  R[n] &amp;= 0x0000FFFF;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mac.l	@Rm+,@Rn+</div>
<div class="col_cont_3">Signed, (Rn) * (Rm) + MAC -&gt; MAC
32 * 32 + 64 -&gt; 64 bits</div>
<div class="col_cont_4">0000nnnnmmmm1111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">      2           
2                 
2     2     4     </div>
<div class="col_cont_8">      2-4         
2-5               
2/4   5     5     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs signed multiplication of the 32-bit operands whose addresses are the
contents of general registers Rm and Rn, adds the 64-bit result to the MAC
register contents, and stores the result in the MAC register.
Operands Rm and Rn are each incremented by 4 each time they are read.
<br><br>
When the S bit is cleared to 0, the 64-bit result is stored in the coupled MACH
and MACL registers.
<br><br>
When bit S is set to 1, addition to the MAC register is a saturation operation
of 48 bits starting from the LSB. For the saturation operation, only the lower
48 bits of the MACL register are enabled and the result is limited to a range
of 0xFFFF800000000000 (minimum) and 0x00007FFFFFFFFFFF (maximum).
<br><br>

<i><b>Note</b></i><br>On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.  In the case of consecutive executions of
MAC.W/MAC.L, the latency is decreased to 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MACL (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;
  long tempm, tempn, fnLmL;

  tempn = Read_32 (R[n]);
  R[n] += 4;
  tempm = Read_32 (R[m]);
  R[m] += 4;

  if ((long)(tempn ^ tempm) &lt; 0)
    fnLmL = -1;
  else
    fnLmL = 0;

  if (tempn &lt; 0)
    tempn = 0 - tempn;
  if (tempm &lt; 0)
    tempm = 0 - tempm;

  temp1 = (unsigned long)tempn;
  temp2 = (unsigned long)tempm;

  RnL = temp1 &amp; 0x0000FFFF;
  RnH = (temp1 &gt;&gt; 16) &amp; 0x0000FFFF;
  RmL = temp2 &amp; 0x0000FFFF;
  RmH = (temp2 &gt;&gt; 16) &amp; 0x0000FFFF;
  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0;

  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) &amp; 0xFFFF0000;

  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) &amp; 0x0000FFFF) + temp3;

  if(fnLmL &lt; 0)
  {
    Res2 = ~Res2;
    if (Res0 == 0)
      Res2++;
    else
      Res0 = (~Res0) + 1;
  }

  if (S == 1)
  {
    Res0 = MACL + Res0;
    if (MACL &gt; Res0)
      Res2++;

    Res2 += MACH &amp; 0x0000FFFF;

    if (((long)Res2 &lt; 0) &amp;&amp; (Res2 &lt; 0xFFFF8000))
    {
      Res2 = 0xFFFF8000;
      Res0 = 0x00000000;
    }

    if (((long)Res2 &gt; 0) &amp;&amp; (Res2 &gt; 0x00007FFF))
    {
      Res2 = 0x00007FFF;
      Res0 = 0xFFFFFFFF;
    }

    MACH = (Res2 &amp; 0x0000FFFF) | (MACH &amp; 0xFFFF0000);
    MACL = Res0;
  }
  else
  {
    Res0 = MACL + Res0;
    if (MACL &gt; Res0)
      Res2 ++;

    Res2 += MACH;
    MACH = Res2;
    MACL = Res0;
  }

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mac.w	@Rm+,@Rn+</div>
<div class="col_cont_3">Signed, (Rn) * (Rm) + MAC -&gt; MAC
SH1: 16 * 16 + 42 -&gt; 42 bits
Other: 16 * 16 + 64 -&gt; 64 bits</div>
<div class="col_cont_4">0100nnnnmmmm1111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">2     2           
2                 
2     2     3     </div>
<div class="col_cont_8">2-3   2-3         
2-5               
2/4   4     4     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs signed multiplication of the 16-bit operands whose addresses are the
contents of general registers Rm and Rn, adds the 32-bit result to the MAC
register contents, and stores the result in the MAC register.
Operands Rm and Rn are each incremented by 2 each time they are read.
<br><br>
If the S bit is 0, a 16 * 16 + 64 -&gt; 64-bit multiply-and-accumulate operation
is performed, and the 64-bit result is stored in the linked MACH and MACL
registers.
<br><br>
If the S bit is 1, a 16 * 16 + 32 -&gt; 32-bit multiply-and-accumulate operation is
performed, and the addition to the MAC register contents is a saturation
operation. In a saturation operation, only the MACL register is valid, and the
result range is limited to 0x80000000 (minimum value) to 0x7FFFFFFF
(maximum value). If overflow occurs, the LSB of the MACH register is set to 1.
0x80000000 (minimum value) is stored in the MACL register if the result
overflows in the negative direction, and 0x7FFFFFFF (maximum value) is stored
if the result overflows in the positive direction
<br><br>

<i><b>Note</b></i><br>When the S bit is 0, the SH2 and SH-DSP CPU perform a 16 * 16 + 64 -&gt; 64 bit
multiply and accumulate operation and the SH1 CPU performs a 16 * 16 + 42 -&gt;
42 bit multiply and accumulate operation.
<br><br>
On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.  In the case of consecutive executions of
MAC.W/MAC.L, the latency is decreased to 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MACW (int m, int n)
{
  long tempm, tempn, dest, src, ans;
  unsigned long templ;

  tempn = Read_16 (R[n]);
  R[n] += 2;
  tempm = Read_16 (R[m]);
  R[m] += 2;

  templ = MACL;
  tempm = ((long)(short)tempn * (long)(short)tempm);

  if ((long)MACL &gt;= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)tempm &gt;= 0)
  {
    src = 0;
    tempn = 0;
  }
  else
  {
    src = 1;
    tempn = 0xFFFFFFFF;
  }

  src += dest;
  MACL += tempm;

  if ((long)MACL &gt;= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (S == 1)
  {
    if (ans == 1)
    {
      #if SH1
      if (src == 0 || src == 2)
        MACH |= 0x00000001;
      #endif

      if (src == 0)
        MACL = 0x7FFFFFFF;
      if (src == 2)
        MACL = 0x80000000;
    }
  }
  else
  {
    MACH += tempn;
    if (templ &gt; MACL)
      MACH += 1;

    #if SH1
    if ((MACH &amp; 0x00000200) == 0)
      MACH &amp;= 0x000003FF;
    else
      MACH |= 0xFFFFFC00;
    #endif
  }

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mul.l	Rm,Rn</div>
<div class="col_cont_3">Rn * Rm -&gt; MACL
32 * 32 -&gt; 32 bits</div>
<div class="col_cont_4">0000nnnnmmmm0111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">      2           
2                 
2     1     2     </div>
<div class="col_cont_8">      2-4         
2-4               
4/4   2     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs 32-bit multiplication of the contents of general registers Rn and Rm,
and stores the lower 32 bits of the result in the MACL register. The contents
of MACH are not changed.
<br><br>

<i><b>Note</b></i><br>On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MULL (int m, int n)
{
  MACL = R[n] * R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">mulr	R0,Rn</div>
<div class="col_cont_3">R0 * Rn -&gt; Rn
32 * 32 -&gt; 32 bits</div>
<div class="col_cont_4">0100nnnn10000000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            2     </div>
<div class="col_cont_8">                  
                  
            4     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs 32-bit multiplication of the contents of general register R0 by Rn,
and stores the lower 32 bits of the result in general register Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MULR (int n)
{
  R[n] = R[0] * R[n];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">muls.w	Rm,Rn</div>
<div class="col_cont_3">Signed, Rn * Rm -&gt; MACL
16 * 16 -&gt; 32 bits</div>
<div class="col_cont_4">0010nnnnmmmm1111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">2     2           
2                 
2     1     1     </div>
<div class="col_cont_8">1-3   1-3         
1-3               
4/4   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs 16-bit multiplication of the contents of general registers Rn and Rm,
and stores the 32-bit result in the MACL register. The multiplication is
performed as a signed arithmetic operation. The contents of MACH are not
changed.
<br><br>

<i><b>Note</b></i><br>On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MULS (int m, int n)
{
  MACL = ((long)(short)R[n] * (long)(short)R[m]);
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">mulu.w	Rm,Rn</div>
<div class="col_cont_3">Unsigned, Rn * Rm -&gt; MACL
16 * 16 -&gt; 32 bits</div>
<div class="col_cont_4">0010nnnnmmmm1110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">2     2           
2                 
2     1     1     </div>
<div class="col_cont_8">1-3   1-3         
1-3               
4/4   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs 16-bit multiplication of the contents of general registers Rn and Rm,
and stores the 32-bit result in the MACL register. The multiplication is
performed as an unsigned arithmetic operation. The contents of MACH are not
changed.
<br><br>

<i><b>Note</b></i><br>On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MULU (int m, int n)
{
  MACL = ((unsigned long)(unsigned short)R[n]* (unsigned long)(unsigned short)R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">neg	Rm,Rn</div>
<div class="col_cont_3">0 - Rm -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm1011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds the two's complement of the contents of general register Rm and stores
the result in Rn. That is, it subtracts Rm from 0 and stores the result in Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void NEG (int m, int n)
{
  R[n] = 0 - R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">negc	Rm,Rn</div>
<div class="col_cont_3">0 - Rm - T -&gt; Rn, borrow -&gt; T</div>
<div class="col_cont_4">0110nnnnmmmm1010</div>
<div class="col_cont_5">Borrow
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of general register Rm and the T bit from 0 and stores
the result in Rn. A borrow resulting from the operation is reflected in the
T bit. This instruction can be  used for sign inversion of a value exceeding
32 bits.
<br><br>

<i><b>Note</b></i><br>This instruction can also be used to efficiently store the reversed T bit value
in a general register, if the MOVRT instruction is not available.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void NEGC (int m, int n)
{
  unsigned long temp;
  temp = 0 - R[m];
  R[n] = temp - T;

  if (0 &lt; temp)
    T = 1;
  else
    T = 0;

  if (temp &lt; R[n])
    T = 1;

  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">! Sign inversion of r0:r1 (64 bits)

clrt
negc   r1,r1    ! Before execution: r1 = 0x00000001, T = 0
                ! After execution: r1 = 0xFFFFFFFF, T = 1
negc   r0,r0    ! Before execution: r0 = 0x00000000, T = 1
                ! After execution: r0 = 0xFFFFFFFF, T = 1

- - - - - - - - - - - - - - - - 

! Store reversed T bit in r0

mov    #-1,r1
negc   r1,r0    ! r0 = 0 - (-1) - T
                ! r0 = 1 - T
                ! Notice that T bit will be modified by the negc operation.
                ! In this case, T will be always set to 1.
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sub	Rm,Rn</div>
<div class="col_cont_3">Rn - Rm -&gt; Rn</div>
<div class="col_cont_4">0011nnnnmmmm1000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of general register Rm from the contents of general
register Rn and stores the result in Rn. For immediate data subtraction,
ADD #imm,Rn should be used.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SUB (int m, int n)
{
  R[n] -= R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">subc	Rm,Rn</div>
<div class="col_cont_3">Rn - Rm - T -&gt; Rn, borrow -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm1010</div>
<div class="col_cont_5">Borrow
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of general register Rm and the T bit from the contents of
general register Rn, and stores the result in Rn. A borrow resulting from the
operation is reflected in the T bit. This instruction is used for subtractions
exceeding 32 bits.
<br><br>

<i><b>Note</b></i><br>This instruction can also be used to store the T bit to all the bits of a
general register.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SUBC (int m, int n)
{
  unsigned long tmp0, tmp1;
  tmp1 = R[n] - R[m];
  tmp0 = R[n];
  R[n] = tmp1 - T;

  if (tmp0 &lt; tmp1)
    T = 1;
  else
    T = 0;

  if (tmp1 &lt; R[n])
    T = 1;

  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">! r0:r1(64 bits) - r2:r3(64 bits) = r0:r1(64 bits)

clrt
subc   r3,r1    ! Before execution: T = 0, r1 = 0x00000000, r3 = 0x00000001
                ! After execution: T = 1, r1 = 0xFFFFFFFF
subc   r2,r0    ! Before execution: T = 1, r0 = 0x00000000, r2 = 0x00000000
                ! After execution: T = 1, r0 = 0xFFFFFFFF

- - - - - - - - - - - - - - - - 

! Store T bit to all bits of r0

subc   r0,r0    ! r0 = r0 - r0 - T
                ! r0 = 0 - T
                ! Notice that the T bit is modified by the subc operation.
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">subv	Rm,Rn</div>
<div class="col_cont_3">Rn - Rm -&gt; Rn, underflow -&gt; T</div>
<div class="col_cont_4">0011nnnnmmmm1011</div>
<div class="col_cont_5">Underflow
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of general register Rm from the contents of general
register Rn, and stores the result in Rn. If underflow occurs, the T bit is set.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SUBV (int m, int n)
{
  long dest, src, ans;

  if ((long)R[n] &gt;= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)R[m] &gt;= 0)
    src = 0;
  else
    src = 1;

  src += dest;
  R[n] -= R[m];

  if ((long)R[n] &gt;= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (src == 1)
  {
    if (ans == 1)
      T = 1;
    else
      T = 0;
  }
  else
    T = 0;

  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">subv   r0,r1    ! Before execution: r0 = 0x00000002, r1 = 0x80000001
                ! After execution: r1 = 0x7FFFFFFF, T = 1

subv   r2,r3    ! Before execution: r2 = 0xFFFFFFFE, r3 = 0x7FFFFFFE
                ! After execution r3 = 0x80000000, T = 1
</p></pre>

</div></div>
<br><b>Logic Operation Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">and	Rm,Rn</div>
<div class="col_cont_3">Rn &amp; Rm -&gt; Rn</div>
<div class="col_cont_4">0010nnnnmmmm1001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs the contents of general registers Rn and Rm and stores the result in Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void AND (int m, int n)
{
  R[n] &amp;= R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">and	#imm,R0</div>
<div class="col_cont_3">R0 &amp; (zero extend)imm -&gt; R0</div>
<div class="col_cont_4">11001001iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.
<br><br>

<i><b>Note</b></i><br>Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
always cleared to zero.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ANDI (int i)
{
  R[0] &amp;= (0x000000FF &amp; (long)i);
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">and.b	#imm,@(R0,GBR)</div>
<div class="col_cont_3">(R0 + GBR) &amp; (zero extend)imm -&gt; (R0 + GBR)</div>
<div class="col_cont_4">11001101iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">2     2           
2                 
4     3     3     </div>
<div class="col_cont_8">3     3           
3                 
4     3           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs the contents of the memory byte indicated by the indirect GBR address with
the immediate value and writes the result back to the memory byte.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ANDM (long i)
{
  long temp = Read_8 (GBR + R[0]);
  temp &amp;= 0x000000FF &amp; (long)i;
  Write_8 (GBR + R[0], temp);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br>
Exceptions are checked taking a data access by this instruction as a byte load
and a byte store.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">not	Rm,Rn</div>
<div class="col_cont_3">~Rm -&gt; Rn</div>
<div class="col_cont_4">0110nnnnmmmm0111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds the one's complement of the contents of general register Rm and stores
the result in Rn. That is, it inverts the Rm bits and stores the result in Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void NOT (int m, int n)
{
  R[n] = ~R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">or	Rm,Rn</div>
<div class="col_cont_3">Rn | Rm -&gt; Rn</div>
<div class="col_cont_4">0010nnnnmmmm1011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ORs the contents of general registers Rn and Rm and stores the result in Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void OR (int m, int n)
{
  R[n] |= R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">or	#imm,R0</div>
<div class="col_cont_3">R0 | (zero extend)imm -&gt; R0</div>
<div class="col_cont_4">11001011iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ORs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.
<br><br>

<i><b>Note</b></i><br>Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
not modified.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ORI (int i)
{
  R[0] |= (0x000000FF &amp; (long)i);
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">or.b	#imm,@(R0,GBR)</div>
<div class="col_cont_3">(R0 + GBR) | (zero extend)imm -&gt; (R0 + GBR)</div>
<div class="col_cont_4">11001111iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">2     2           
2                 
4     3     3     </div>
<div class="col_cont_8">3     3           
3                 
4     3     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ORs the contents of the memory byte indicated by the indirect GBR address with
the immediate value and writes the result back to the memory byte.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ORM (int i)
{
  long temp = Read_8 (GBR + R[0]);
  temp |= (0x000000FF &amp; (long)i);
  Write_8 (GBR + R[0], temp);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br>
Exceptions are checked taking a data access by this instruction as a byte load
and a byte store.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">tas.b	@Rn</div>
<div class="col_cont_3">If (Rn) = 0: 1 -&gt; T
Else: 0 -&gt; T
1 -&gt; MSB of (Rn)</div>
<div class="col_cont_4">0100nnnn00011011</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">2     2           
2                 
5     4     3     </div>
<div class="col_cont_8">4     4           
3/4               
5     4     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Reads byte data from the address specified by general register Rn, and sets the
T bit to 1 if the data is 0, or clears the T bit to 0 if the data is not 0.
Then, data bit 7 is set to 1, and the data is written to the address specified
by Rn. During this operation, the bus is not released.
<br><br>

On SH4 and SH4A this instruction purges the cache block corresponding to the
memory area specified by the contents of general register Rn. 
The purge operation is executed as follows.<br>
In a purge operation, data is accessed using the contents of general register Rn
as the effective address. If there is a cache hit and the corresponding cache
block is dirty (U bit = 1), the contents of that cache block are written back to
external memory, and the cache block is then invalidated (by clearing the V bit
to 0). If there is a cache hit and the corresponding cache block is clean (U bit
= 0), the cache block is simply invalidated (by clearing the V bit to 0). A
purge is not executed in the event of a cache miss, or if the accessed memory
location is non-cacheable.
<br><br>

<i><b>Note</b></i><br>The two TAS.B memory accesses are executed automatically. Another memory access
is not executed between the two TAS.B accesses.
<br><br>
On SH3 the destination of the TAS instruction should be placed in a
non-cacheable space when the cache is enabled.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void TAS (int n)
{
  int temp = Read_8 (R[n]); // Bus Lock

  if (temp == 0)
    T = 1;
  else
    T = 0;

  temp |= 0x00000080;
  Write_8 (R[n], temp);  // Bus unlock
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br>
Exceptions are checked taking a data access by this instruction as a byte load
and a byte store.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">tst	Rm,Rn</div>
<div class="col_cont_3">If Rn &amp; Rm = 0: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">0010nnnnmmmm1000</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs the contents of general registers Rn and Rm, and sets the T bit if the
result is zero. If the result is nonzero, the T bit is cleared. The contents of
Rn are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void TST (int m, int n)
{
  if ((R[n] &amp; R[m]) == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">tst	#imm,R0</div>
<div class="col_cont_3">If R0 &amp; (zero extend)imm = 0: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">11001000iiiiiiii</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs the contents of general register R0 and the zero-extended immediate value
and sets the T bit if the result is zero. If the result is nonzero, the T bit
is cleared. The contents of Rn are not changed.
<br><br>

<i><b>Note</b></i><br>Since the 8-bit immediate value is zero-extended, this instruction can only be
used to test the lower 8 bits of R0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void TSTI (int i)
{
  long temp = R[0] &amp; (0x000000FF &amp; (long)i);

  if (temp == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">tst.b	#imm,@(R0,GBR)</div>
<div class="col_cont_3">If (R0 + GBR) &amp; (zero extend)imm = 0: 1 -&gt; T
Else 0: -&gt; T</div>
<div class="col_cont_4">11001100iiiiiiii</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">2     2           
2                 
3     3     3     </div>
<div class="col_cont_8">3     3           
3                 
3     3     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>ANDs the contents of the memory byte indicated by the indirect GBR address with
the zero-extended immediate value and sets the T bit if the result is zero.
If the result is nonzero, the T bit is cleared.
The contents of the memory byte are not changed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void TSTM (int i)
{
  long temp = Read_8 (GBR + R[0]);
  temp &amp;= (0x000000FF &amp; (long)i);

  if (temp == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br>
Exceptions are checked taking a data access by this instruction as a byte load
and a byte store.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">xor	Rm,Rn</div>
<div class="col_cont_3">Rn ^ Rm -&gt; Rn</div>
<div class="col_cont_4">0010nnnnmmmm1010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>XORs the contents of general registers Rn and Rm and stores the result in Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void XOR (long m, long n)
{
  R[n] ^= R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">xor	#imm,R0</div>
<div class="col_cont_3">R0 ^ (zero extend)imm -&gt; R0</div>
<div class="col_cont_4">11001010iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>XORs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.
<br><br>

<i><b>Note</b></i><br>Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
not modified.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void XORI (int i)
{
  R[0] ^= (0x000000FF &amp; (long)i);
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">xor.b	#imm,@(R0,GBR)</div>
<div class="col_cont_3">(R0 + GBR) ^ (zero extend)imm -&gt; (R0 + GBR)</div>
<div class="col_cont_4">11001110iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">2     2           
2                 
4     3     3     </div>
<div class="col_cont_8">3     3           
3                 
4     3     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>XORs the contents of the memory byte indicated by the indirect GBR address with
the immediate value and writes the result back to the memory byte.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void XORM (int i)
{
  int temp = Read_8 (GBR + R[0]);
  temp ^= (0x000000FF &amp; (long)i);
  Write_8 (GBR + R[0], temp);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br>
Exceptions are checked taking a data access by this instruction as a byte load
and a byte store.
<br><br>

</div></div>
<br><b>Shift Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">rotcl	Rn</div>
<div class="col_cont_3">T &lt;&lt; Rn &lt;&lt; T</div>
<div class="col_cont_4">0100nnnn00100100</div>
<div class="col_cont_5">MSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Rotates the contents of general register Rn one bit to the left through the
T bit, and stores the result in Rn. The bit rotated out of the operand is
transferred to the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/rotcl.svg" height="100">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ROTCL (int n)
{
  long temp;

  if ((R[n] &amp; 0x80000000) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &lt;&lt;= 1;

  if (T == 1)
    R[n] |= 0x00000001;
  else
    R[n] &amp;= 0xFFFFFFFE;

  if (temp == 1)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">rotcr	Rn</div>
<div class="col_cont_3">T &gt;&gt; Rn &gt;&gt; T</div>
<div class="col_cont_4">0100nnnn00100101</div>
<div class="col_cont_5">LSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Rotates the contents of general register Rn one bit to the right through the
T bit, and stores the result in Rn. The bit rotated out of the operand is
transferred to the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/rotcr.svg" height="100">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ROTCR (int n)
{
  long temp;

  if ((R[n] &amp; 0x00000001) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &gt;&gt;= 1;

  if (T == 1)
    R[n] |= 0x80000000;
  else
    R[n] &amp;= 0x7FFFFFFF;

  if (temp == 1)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">rotl	Rn</div>
<div class="col_cont_3">T &lt;&lt; Rn &lt;&lt; MSB</div>
<div class="col_cont_4">0100nnnn00000100</div>
<div class="col_cont_5">MSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Rotates the contents of general register Rn one bit to the left, and stores the
result in Rn. The bit rotated out of the operand is transferred to the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/rotl.svg" height="100">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ROTL (int n)
{
  if ((R[n] &amp; 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;

  if (T == 1)
    R[n] |= 0x00000001;
  else
    R[n] &amp;= 0xFFFFFFFE;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">rotr	Rn</div>
<div class="col_cont_3">LSB &gt;&gt; Rn &gt;&gt; T</div>
<div class="col_cont_4">0100nnnn00000101</div>
<div class="col_cont_5">LSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Rotates the contents of general register Rn one bit to the right, and stores the
result in Rn. The bit rotated out of the operand is transferred to the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/rotr.svg" height="100">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ROTR (int n)
{
  if ((R[n] &amp; 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  R[n] &gt;&gt;= 1;

  if (T == 1)
    R[n] |= 0x80000000;
  else
    R[n] &amp;= 0x7FFFFFFF;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shad	Rm,Rn</div>
<div class="col_cont_3">If Rm &gt;= 0: Rn &lt;&lt; Rm -&gt; Rn
If Rm &lt; 0: Rn &gt;&gt; |Rm| -&gt; [MSB -&gt; Rn]</div>
<div class="col_cont_4">0100nnnnmmmm1100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">                  
1                 
1     1     1     </div>
<div class="col_cont_8">                  
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically shifts the contents of general register Rn. General register Rm
specifies the shift direction and the number of bits to be shifted.
<br><br>
Rn register contents are shifted to the left if the Rm register value is
positive, and to the right if negative. In a shift to the right, the MSB is
added at the upper end.
<br><br>
The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)
of the Rm register. If the value is negative (MSB = 1), the Rm register is
represented as a two's complement. The left shift range is 0 to 31, and the
right shift range, 1 to 32.
<br><img src="./Renesas SH Instruction Set Summary_files/shad.svg" height="220">
<br><br>

<i><b>Note</b></i><br>On SH4, if there is a load of the shift amount immediately before an SHAD/SHLD
instruction, the latency of the load is increased by 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHAD (int m, int n)
{
  int sgn = R[m] &amp; 0x80000000;

  if (sgn == 0)
    R[n] &lt;&lt;= (R[m] &amp; 0x1F);
  else if ((R[m] &amp; 0x1F) == 0)
  {
    if ((R[n] &amp; 0x80000000) == 0)
      R[n] = 0;
    else
      R[n] = 0xFFFFFFFF;
  }
  else
    R[n] = (long)R[n] &gt;&gt; ((~R[m] &amp; 0x1F) + 1);

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shal	Rn</div>
<div class="col_cont_3">T &lt;&lt; Rn &lt;&lt; 0</div>
<div class="col_cont_4">0100nnnn00100000</div>
<div class="col_cont_5">MSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically shifts the contents of general register Rn one bit to the left
and stores the result in Rn. The bit shifted out of the operand is transferred
to the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/shal.svg" height="100">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHAL (int n)
{
  if ((R[n] &amp; 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shar	Rn</div>
<div class="col_cont_3">MSB &gt;&gt; Rn &gt;&gt; T</div>
<div class="col_cont_4">0100nnnn00100001</div>
<div class="col_cont_5">LSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically shifts the contents of general register Rn one bit to the right
and stores the result in Rn. The bit shifted out of the operand is transferred
to the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/shar.svg" height="100">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHAR (int n)
{
  long temp;

  if ((R[n] &amp; 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  if ((R[n] &amp; 0x80000000) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &gt;&gt;= 1;

  if (temp == 1)
    R[n] |= 0x80000000;
  else
    R[n] &amp;= 0x7FFFFFFF;

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shld	Rm,Rn</div>
<div class="col_cont_3">If Rm &gt;= 0: Rn &lt;&lt; Rm -&gt; Rn
If Rm &lt; 0: Rn &gt;&gt; |Rm| -&gt; [0 -&gt; Rn]</div>
<div class="col_cont_4">0100nnnnmmmm1101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">                  
1                 
1     1     1     </div>
<div class="col_cont_8">                  
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn. General register Rm
specifies the shift direction and the number of bits to be shifted.
<br><br>
Rn register contents are shifted to the left if the Rm register value is
positive, and to the right if negative. In a shift to the right, 0s are added
at the upper end.
<br><br>
The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)
of the Rm register. If the value is negative (MSB = 1), the Rm register is
represented as a two's complement. The left shift range is 0 to 31, and the
right shift range, 1 to 32.
<br><img src="./Renesas SH Instruction Set Summary_files/shld.svg" height="220">
<br><br>

<i><b>Note</b></i><br>On SH4, if there is a load of the shift amount immediately before an SHAD/SHLD
instruction, the latency of the load is increased by 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLD (int m, int n)
{
  int sgn = R[m] &amp; 0x80000000;

  if (sgn == 0)
    R[n] &lt;&lt;= (R[m] &amp; 0x1F);
  else if ((R[m] &amp; 0x1F) == 0)
    R[n] = 0;
  else
    R[n] = (unsigned)R[n] &gt;&gt; ((~R[m] &amp; 0x1F) + 1);

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shll	Rn</div>
<div class="col_cont_3">T &lt;&lt; Rn &lt;&lt; 0</div>
<div class="col_cont_4">0100nnnn00000000</div>
<div class="col_cont_5">MSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn one bit to the left and
stores the result in Rn. The bit shifted out of the operand is transferred to
the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/shll.svg" height="100">
<br><br>

<i><b>Note</b></i><br>Effectively, the operation performed is the same as the SHAL instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLL (int n)
{
  if ((R[n] &amp; 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shll2	Rn</div>
<div class="col_cont_3">Rn &lt;&lt; 2 -&gt; Rn</div>
<div class="col_cont_4">0100nnnn00001000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn 2 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br><img src="./Renesas SH Instruction Set Summary_files/shll2.svg" height="120">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLL2 (int n)
{
  R[n] &lt;&lt;= 2;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shll8	Rn</div>
<div class="col_cont_3">Rn &lt;&lt; 8 -&gt; Rn</div>
<div class="col_cont_4">0100nnnn00011000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn 8 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br><img src="./Renesas SH Instruction Set Summary_files/shll8.svg" height="120">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLL8 (int n)
{
  R[n] &lt;&lt;= 8;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shll16	Rn</div>
<div class="col_cont_3">Rn &lt;&lt; 16 -&gt; Rn</div>
<div class="col_cont_4">0100nnnn00101000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn 16 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br><img src="./Renesas SH Instruction Set Summary_files/shll16.svg" height="120">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLL16 (int n)
{
  R[n] &lt;&lt;= 16;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shlr	Rn</div>
<div class="col_cont_3">0 &gt;&gt; Rn &gt;&gt; T</div>
<div class="col_cont_4">0100nnnn00000001</div>
<div class="col_cont_5">LSB
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn one bit to the right and
stores the result in Rn. The bit shifted out of the operand is transferred to
the T bit.
<br><img src="./Renesas SH Instruction Set Summary_files/shlr.svg" height="100">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLR (int n)
{
  if ((R[n] &amp; 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  R[n] &gt;&gt;= 1;
  R[n] &amp;= 0x7FFFFFFF;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shlr2	Rn</div>
<div class="col_cont_3">Rn &gt;&gt; 2 -&gt; [0 -&gt; Rn]</div>
<div class="col_cont_4">0100nnnn00001001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn 2 bits to the right, and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br><img src="./Renesas SH Instruction Set Summary_files/shlr2.svg" height="120">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLR2 (int n)
{
  R[n] &gt;&gt;= 2;
  R[n] &amp;= 0x3FFFFFFF;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shlr8	Rn</div>
<div class="col_cont_3">Rn &gt;&gt; 8 -&gt; [0 -&gt; Rn]</div>
<div class="col_cont_4">0100nnnn00011001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn 8 bits to the right, and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br><img src="./Renesas SH Instruction Set Summary_files/shlr8.svg" height="120">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLR8 (int n)
{
  R[n] &gt;&gt;= 8;
  R[n] &amp;= 0x00FFFFFF;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">shlr16	Rn</div>
<div class="col_cont_3">Rn &gt;&gt; 16 -&gt; [0 -&gt; Rn]</div>
<div class="col_cont_4">0100nnnn00101001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
EX    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the contents of general register Rn 16 bits to the right and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br><img src="./Renesas SH Instruction Set Summary_files/shlr16.svg" height="120">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SHLR16 (int n)
{
  R[n] &gt;&gt;= 16;
  R[n] &amp;= 0x0000FFFF;
  PC += 2;
}
</p></pre>

</div></div>
<br><b>Branch Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">bf	label</div>
<div class="col_cont_3">If T = 0: disp*2 + PC + 4 -&gt; PC
Else: nop</div>
<div class="col_cont_4">10001011dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
BR    BR          </div>
<div class="col_cont_7">1     1           
1                 
1     1-3   1/3   </div>
<div class="col_cont_8">1/3   1/3         
1/3               
1/2   1     1/3   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>This is a conditional branch instruction that references the T bit. The branch
is taken if T = 0, and not taken if T = 1. The branch destination is address
(PC + 4 + displacement * 2).  The PC source value is the BF instruction address.
As the 8-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -256 to +254 bytes from the BF
instruction.
<br><br>

<i><b>Note</b></i><br>If the branch destination cannot be reached, the branch must be handled by using
BF in combination with a BRA or JMP instruction, for example.
<br><br>
On some SH4 implementations a branch with a displacement value of zero does not
cause the pipeline I-stage to be stalled even if the branch is taken.  This can
be utilized for efficient conditional operations.
<br><br>
On some SH2E implementations (SH7055) there is an FPU related hardware bug
which affects this instruction.  The recommended workaround is to use bt/s with
a nop in the delay slot.
See also documents "sh2eoc.pdf" and "win_update_a.pdf".
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BF (int d)
{
  int disp;
  if ((d &amp; 0x80) == 0)
    disp = (0x000000FF &amp; d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 0)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">bf/s	label</div>
<div class="col_cont_3">If T = 0: disp*2 + PC + 4 -&gt; PC
Else: nop
(Delayed branch)</div>
<div class="col_cont_4">10001111dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
BR    BR          </div>
<div class="col_cont_7">      1           
1                 
1     1-3   1/2   </div>
<div class="col_cont_8">      1/2         
1/2               
1/2   1     1/2   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>This is a delayed conditional branch instruction that references the T bit.
If T = 1, the next instruction is executed and the branch is not taken.
If T = 0, the branch is taken after execution of the next instruction.
<br><br>
The branch destination is address (PC + 4 + displacement * 2). The PC source
value is the BF/S instruction address.  As the 8-bit displacement is multiplied
by two after sign-extension, the branch destination can be located in the range
from -256 to +254 bytes from the BF/S instruction.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, when the branch condition is satisfied,
the instruction following this instruction is executed before the branch
destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>
If this instruction is located in the delay slot immediately following a delayed
branch instruction, it is identified as a slot illegal instruction.
<br><br>
If the branch destination cannot be reached, the branch must be handled by using
BF/S in combination with a BRA or JMP instruction, for example.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BFS (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;
  if ((d &amp; 0x80) == 0)
    disp = (0x000000FF &amp; d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 0)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 4;

  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">bt	label</div>
<div class="col_cont_3">If T = 1: disp*2 + PC + 4 -&gt; PC
Else: nop</div>
<div class="col_cont_4">10001001dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
BR    BR          </div>
<div class="col_cont_7">1     1           
1                 
1     1-3   1/3   </div>
<div class="col_cont_8">1/3   1/3         
1/3               
1/2   1     1/3   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>This is a conditional branch instruction that references the T bit. The branch
is taken if T = 1, and not taken if T = 0.  The branch destination is address
(PC + 4 + displacement * 2). The PC source value is the BT instruction address.
As the 8-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -256 to +254 bytes from the BT
instruction.
<br><br>

<i><b>Note</b></i><br>If the branch destination cannot be reached, the branch must be handled by using
BT in combination with a BRA or JMP instruction, for example.
<br><br>
On some SH4 implementations a branch with a displacement value of zero does not
cause the pipeline I-stage to be stalled even if the branch is taken.  This can
be utilized for efficient conditional operations.
<br><br>
On some SH2E implementations (SH7055) there is an FPU related hardware bug
which affects this instruction.  The recommended workaround is to use bt/s with
a nop in the delay slot.
See also documents "sh2eoc.pdf" and "win_update_a.pdf".
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BT (int d)
{
  int disp;
  if ((d &amp; 0x80) == 0)
    disp = (0x000000FF &amp; d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 1)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">bt/s	label</div>
<div class="col_cont_3">If T = 1: disp*2 + PC + 4 -&gt; PC
Else: nop
(Delayed branch)</div>
<div class="col_cont_4">10001101dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
BR    BR          </div>
<div class="col_cont_7">      1           
1                 
1     1-3   1/2   </div>
<div class="col_cont_8">      1/2         
1/2               
1/2   1     1/2   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>This is a conditional branch instruction that references the T bit. The branch
is taken if T = 1, and not taken if T = 0.  The PC source value is the BT/S
instruction address. As the 8-bit displacement is multiplied by two after
sign-extension, the branch destination can be located in the range from -256 to
+254 bytes from the BT/S instruction.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, when the branch condition is satisfied,
the instruction following this instruction is executed before the branch
destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>
If the branch destination cannot be reached, the branch must be handled by using
BT/S in combination with a BRA or JMP instruction, for example.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BTS (int d)
{
  int disp;
  unsigned temp;
  temp = PC;

  if ((d &amp; 0x80) == 0)
    disp = (0x000000FF &amp; d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 1)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 4;

  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">bra	label</div>
<div class="col_cont_3">disp*2 + PC + 4 -&gt; PC
(Delayed branch)</div>
<div class="col_cont_4">1010dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
BR    BR          </div>
<div class="col_cont_7">1     1           
1                 
1     1-3   2     </div>
<div class="col_cont_8">2     2           
2                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>This is an unconditional branch instruction. The branch destination is address
(PC + 4 + displacement * 2). The PC source value is the BRA instruction address.
As the 12-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -4096 to +4094 bytes from the BRA
instruction. If the branch destination cannot be reached, this branch can be
performed with a JMP instruction.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BRA (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;

  if ((d &amp; 0x800) == 0)
    disp = (0x00000FFF &amp; d);
  else
    disp = (0xFFFFF000 | d);

  PC = PC + 4 + (disp &lt;&lt; 1);
  Delay_Slot(temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">braf	Rm</div>
<div class="col_cont_3">Rm + PC + 4 -&gt; PC
(Delayed branch)</div>
<div class="col_cont_4">0000mmmm00100011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    BR          </div>
<div class="col_cont_7">      1           
1                 
2     4     2     </div>
<div class="col_cont_8">      2           
2                 
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>This is an unconditional branch instruction. The branch destination is address
(PC + 4 + Rm).
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BRAF (int m)
{
  unsigned int temp;
  temp = PC;
  PC = PC + 4 + R[m];
  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">bsr	label</div>
<div class="col_cont_3">PC + 4 -&gt; PR, disp*2 + PC + 4 -&gt; PC
(Delayed branch)</div>
<div class="col_cont_4">1011dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
BR    BR          </div>
<div class="col_cont_7">1     1           
1                 
1     1-3   2     </div>
<div class="col_cont_8">2     2           
2                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Branches to address (PC + 4 + displacement * 2), and stores address (PC + 4) in
PR. The PC source value is the BSR instruction address.
As the 12-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -4096 to +4094 bytes from the BSR
instruction. If the branch destination cannot be reached, this branch can be
performed with a JSR instruction.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BSR (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;

  if ((d &amp; 0x800) == 0)
    disp = (0x00000FFF &amp; d);
  else
    disp = (0xFFFFF000 | d);

  PR = PC + 4;
  PC = PC + 4 + (disp &lt;&lt; 1);
  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">      SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">bsrf	Rm</div>
<div class="col_cont_3">PC + 4 -&gt; PR, Rm + PC + 4 -&gt; PC
(Delayed branch)</div>
<div class="col_cont_4">0000mmmm00000011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    BR          </div>
<div class="col_cont_7">      1           
1                 
2     4     2     </div>
<div class="col_cont_8">      2           
2                 
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Branches to address (PC + 4 + Rm), and stores address (PC + 4) in PR. The PC
source value is the BSRF instruction address. The branch destination address is
the result of adding the 32-bit contents of general register Rm to PC + 4.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void BSRF (int m)
{
  unsigned int temp;
  temp = PC;
  PR = PC + 4;
  PC = PC + 4 + R[m];
  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">jmp	@Rm</div>
<div class="col_cont_3">Rm -&gt; PC
(Delayed branch)</div>
<div class="col_cont_4">0100mmmm00101011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    BR          </div>
<div class="col_cont_7">1     1           
1                 
2     4     2     </div>
<div class="col_cont_8">2     2           
2                 
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Unconditionally makes a delayed branch to the address specified by Rm.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void JMP (int m)
{
  unsigned int temp;
  temp = PC;
  PC = R[m];
  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">jsr	@Rm</div>
<div class="col_cont_3">PC + 4 -&gt; PR, Rm -&gt; PC
(Delayed branch)</div>
<div class="col_cont_4">0100mmmm00001011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    BR          </div>
<div class="col_cont_7">1     1           
1                 
2     4     2     </div>
<div class="col_cont_8">2     2           
2                 
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Makes a delayed branch to the subroutine procedure at the specified address
after execution of the following instruction. Return address (PC + 4) is saved
in PR, and a branch is made to the address indicated by general register Rm.
JSR is used in combination with RTS for subroutine procedure calls.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction.
<br><br>
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void JSR (int m)
{
  unsigned int temp;
  temp = PC;
  PR = PC + 4;
  PC = R[m];
  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">jsr/n	@Rm</div>
<div class="col_cont_3">PC + 2 -&gt; PR, Rm -&gt; PC</div>
<div class="col_cont_4">0100mmmm01001011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Branches to a subroutine procedure at the designated address. The contents of
PC are stored in PR and execution branches to the address indicated by the
contents of general register Rm as 32-bit data. The stored contents of PC
indicate the starting address of the second instruction after the present
instruction. This instruction is used with RTS as a subroutine procedure call.
<br><br>

<i><b>Note</b></i><br>This is not a delayed branch instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void JSRN (int m)
{
  unsigned long temp;
  temp = PC;
  PR = PC + 2;
  PC = R[m];
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">jsr/n	@@(disp8,TBR)</div>
<div class="col_cont_3">PC + 2 -&gt; PR, (disp*4 + TBR) -&gt; PC</div>
<div class="col_cont_4">10000011dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            5     </div>
<div class="col_cont_8">                  
                  
            5     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Branches to a subroutine procedure at the designated address. The contents of PC
are stored in PR and execution branches to the address indicated by the address
read from memory address (disp  4 + TBR). The stored contents of PC indicate
the starting address of the second instruction after the present instruction.
This instruction is used with RTS as a subroutine procedure call.
<br><br>

<i><b>Note</b></i><br>This is not a delayed branch instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void JSRNM (int d)
{
  long disp = (0x000000FF &amp; d);
  PR = PC + 2;
  PC = Read_32 (TBR + (disp &lt;&lt; 2));
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">rts</div>
<div class="col_cont_3">PR -&gt; PC
Delayed branch</div>
<div class="col_cont_4">0000000000001011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    BR          </div>
<div class="col_cont_7">1     1           
1                 
2     1-4   2     </div>
<div class="col_cont_8">2     2           
2                 
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Returns from a subroutine procedure by restoring the PC from PR. Processing
continues from the address indicated by the restored PC value. This instruction
can be used to return from a subroutine procedure called by a BSR or JSR
instruction to the source of the call.
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction. 
<br><br>
If the following instruction is a branch instruction, it is identified as a
slot illegal instruction.
<br><br>
The instruction that restores PR must be executed before the RTS instruction.
This restore instruction cannot be in the RTS delay slot.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void RTS (void)
{
  unsigned int temp;
  temp = PC;
  PC = PR;
  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">rts/n</div>
<div class="col_cont_3">PR -&gt; PC</div>
<div class="col_cont_4">0000000001101011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs a return from a subroutine procedure. That is, the PC is restored from
PR, and processing is resumed from the address indicated by the PC. This
instruction enables a return to be made from a subroutine procedure called by a
BSR or JSR instruction to the origin of the call.
<br><br>

<i><b>Note</b></i><br>This is not a delayed branch instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void RTSN (void)
{
  PC = PR;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">rtv/n	Rm</div>
<div class="col_cont_3">Rm -&gt; R0, PR -&gt; PC</div>
<div class="col_cont_4">0000mmmm01111011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            3     </div>
<div class="col_cont_8">                  
                  
            3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Performs a return from a subroutine procedure after a transfer from specified
general register Rm to R0. That is, after the Rm value is stored in R0, the PC
is restored from PR, and processing is resumed from the address indicated by the
PC. This instruction enables a return to be made from a subroutine procedure
called by a BSR or JSR instruction to the origin of the call.
<br><br>

<i><b>Note</b></i><br>This is not a delayed branch instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void RTVN (int m)
{
  R[0] = R[m];
  PC = PR;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<br><b>System Control Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">clrmac</div>
<div class="col_cont_3">0 -&gt; MACH, 0 -&gt; MACL</div>
<div class="col_cont_4">0000000000101000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
3     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears the MACH and MACL registers.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLRMAC (void)
{
  MACH = 0;
  MACL = 0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        </div>
<div class="col_cont_2">clrs</div>
<div class="col_cont_3">0 -&gt; S</div>
<div class="col_cont_4">0000000001001000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1                 
1     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears the S bit to 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLRS (void)
{
  S = 0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">clrt</div>
<div class="col_cont_3">0 -&gt; T</div>
<div class="col_cont_4">0000000000001000</div>
<div class="col_cont_5">0
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears the T bit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void CLRT (void)
{
  T = 0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">icbi	@Rn</div>
<div class="col_cont_3">Invalidate instruction cache block indicated by logical address</div>
<div class="col_cont_4">0000nnnn11100011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      CO          </div>
<div class="col_cont_7">                  
                  
      16          </div>
<div class="col_cont_8">                  
                  
      13          </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Accesses the instruction cache at the effective address indicated by the
contents of Rn. When the cache is hit, the corresponding cache block is
invalidated (the V bit is cleared to 0). At this time, write-back is not
performed. No operation is performed in the case of a cache miss or access to
a non-cache area.
<br><br>

<i><b>Note</b></i><br>When a program is overwriting RAM to modify its own execution, the corresponding
block of the instruction cache should be invalidated by the ICBI instruction.
This prevents execution of the program from the instruction cache, where the
non-overwritten instructions are stored.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void ICBI (int n)
{
  invalidate_instruction_cache_block (R[n]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Instruction TLB multiple-hit exception</li>
<li>Instruction TLB miss exception</li>
<li>Instruction TLB protection violation exception</li>
<li>Instruction address error</li>
<li>Slot illegal instruction exception</li>
Exceptions may occur when invalidation is not performed.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">ldbank	@Rm,R0</div>
<div class="col_cont_3">(Specified register bank entry) -&gt; R0</div>
<div class="col_cont_4">0100mmmm11100101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            6     </div>
<div class="col_cont_8">                  
                  
            5     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>The register bank entry indicated by the contents of general register Rm is
transferred to general register R0. The register bank number and register stored
in the bank are specified by general register Rm.
<br><img src="./Renesas SH Instruction Set Summary_files/ldbank.svg" height="400">
<br><br>

<i><b>Note</b></i><br>The architecture supports a maximum of 512 banks. However, the number of banks
differs depending on the product.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDBANK (int m)
{
  R[0] = Read_Bank_32 (R[m]);
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">ldc	Rm,SR</div>
<div class="col_cont_3">Rm -&gt; SR</div>
<div class="col_cont_4">0100mmmm00001110</div>
<div class="col_cont_5">LSB
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">1     1           
1                 
4     7     3     </div>
<div class="col_cont_8">1     1           
5                 
4     4     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand in the control register SR.
<br><br>

<i><b>Note</b></i><br>This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCSR (int m)
{
  #if SH1 || SH2 || SH2 || SH3
  SR = R[m] &amp; 0x0FFF0FFF;

  #elif SH2A
  SR = R[m] &amp; 0x000063F3;

  #elif SH4 || SH4A
  SR = R[m] &amp; 0x700083F3;

  #endif

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">ldc.l	@Rm+,SR</div>
<div class="col_cont_3">(Rm) -&gt; SR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00000111</div>
<div class="col_cont_5">LSB
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">1     1           
2                 
4     9     5     </div>
<div class="col_cont_8">3     3           
7                 
4/4   4     4     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand in the control register SR.
<br><br>

<i><b>Note</b></i><br>This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMSR (int m)
{
  #if SH1 || SH2 || SH2 || SH3
  SR = Read_32 (R[m]) &amp; 0x0FFF0FFF;

  #elif SH2A
  SR = Read_32 (R[m]) &amp; 0x000063F3;

  #elif SH4 || SH4A
  SR = Read_32 (R[m]) &amp; 0x700083F3;

  #endif

  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">ldc	Rm,TBR</div>
<div class="col_cont_3">Rm -&gt; TBR</div>
<div class="col_cont_4">0100mmmm01001010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register TBR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCTBR (int m)
{
  TBR = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">ldc	Rm,GBR</div>
<div class="col_cont_3">Rm -&gt; GBR</div>
<div class="col_cont_4">0100mmmm00011110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
3     1     1     </div>
<div class="col_cont_8">1     1           
1/3               
3     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register GBR.
<br><br>

<i><b>Note</b></i><br>This instruction can also be issued in user mode.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCGBR (int m)
{
  GBR = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">ldc.l	@Rm+,GBR</div>
<div class="col_cont_3">(Rm) -&gt; GBR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00010111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
3     1     1     </div>
<div class="col_cont_8">3     3           
1/5               
3/3   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register GBR.
<br><br>

<i><b>Note</b></i><br>This instruction can also be issued in user mode.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMGBR (int m)
{
  GBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">ldc	Rm,VBR</div>
<div class="col_cont_3">Rm -&gt; VBR</div>
<div class="col_cont_4">0100mmmm00101110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1/3               
3     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register VBR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCVBR (int m)
{
  VBR = R[m];
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">ldc.l	@Rm+,VBR</div>
<div class="col_cont_3">(Rm) -&gt; VBR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00100111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">3     3           
1/5               
1/3   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register VBR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMVBR (int m)
{
  VBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldc	Rm,MOD</div>
<div class="col_cont_3">Rm -&gt; MOD</div>
<div class="col_cont_4">0100mmmm01011110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/3   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register MOD.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMOD (int m)
{
  MOD = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldc.l	@Rm+,MOD</div>
<div class="col_cont_3">(Rm) -&gt; MOD, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01010111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/5   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register MOD.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 3 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMMOD (int m)
{
  MOD = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldc	Rm,RE</div>
<div class="col_cont_3">Rm -&gt; RE</div>
<div class="col_cont_4">0100mmmm01111110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/3   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register RE.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCRE (int m)
{
  RE = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldc.l	@Rm+,RE</div>
<div class="col_cont_3">(Rm) -&gt; RE, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01110111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/5   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register RE.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 3 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMRE (int m)
{
  RE = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldc	Rm,RS</div>
<div class="col_cont_3">Rm -&gt; RS</div>
<div class="col_cont_4">0100mmmm01101110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/3   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register RS.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCRS (int m)
{
  RS = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldc.l	@Rm+,RS</div>
<div class="col_cont_3">(Rm) -&gt; RS, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01100111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/5   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register RS.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 3 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMRS (int m)
{
  RS = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        
Privileged</div>
<div class="col_cont_2">ldc	Rm,SGR</div>
<div class="col_cont_3">Rm -&gt; SGR</div>
<div class="col_cont_4">0100mmmm00111010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      CO          </div>
<div class="col_cont_7">                  
                  
      4           </div>
<div class="col_cont_8">                  
                  
      4           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register SGR.
<br><br>

<i><b>Note</b></i><br>Not sure whether it is also available on SH4.
It is not marked as new instruction for SH4A but is also not listed in SH4
manuals.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCSGR (int m)
{
  SGR = R[m];
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        
Privileged</div>
<div class="col_cont_2">ldc.l	@Rm+,SGR</div>
<div class="col_cont_3">(Rm) -&gt; SGR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00110110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      CO          </div>
<div class="col_cont_7">                  
                  
      4           </div>
<div class="col_cont_8">                  
                  
      4           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register SGR.
<br><br>

<i><b>Note</b></i><br>Not sure whether it is also available on SH4.
It is not marked as new instruction for SH4A but is also not listed in SH4
manuals.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMSGR (int m)
{
  SGR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc	Rm,SSR</div>
<div class="col_cont_3">Rm -&gt; SSR</div>
<div class="col_cont_4">0100mmmm00111110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1/3               
3     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register SSR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCSSR (int m)
{
  SSR = R[m],
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc.l	@Rm+,SSR</div>
<div class="col_cont_3">(Rm) -&gt; SSR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00110111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1/5               
1/3   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register SSR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMSSR (int m)
{
  SSR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc	Rm,SPC</div>
<div class="col_cont_3">Rm -&gt; SPC</div>
<div class="col_cont_4">0100mmmm01001110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
3     1           </div>
<div class="col_cont_8">                  
1/3               
1     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register SPC.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCSPC (int m)
{
  SPC = R[m];
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc.l	@Rm+,SPC</div>
<div class="col_cont_3">(Rm) -&gt; SPC, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01000111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1/5               
1/3   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register SPC.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMSPC (int m)
{
  SPC = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc	Rm,DBR</div>
<div class="col_cont_3">Rm -&gt; DBR</div>
<div class="col_cont_4">0100mmmm11111010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">                  
                  
1     4           </div>
<div class="col_cont_8">                  
                  
3     4           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register DBR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCDBR (int m)
{
  DBR = R[m];
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc.l	@Rm+,DBR</div>
<div class="col_cont_3">(Rm) -&gt; DBR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm11110110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">                  
                  
1     4           </div>
<div class="col_cont_8">                  
                  
1/3   4           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in control register DBR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMDBR (int m)
{
  DBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc	Rm,Rn_BANK</div>
<div class="col_cont_3">Rm -&gt; Rn_BANK (n = 0-7)</div>
<div class="col_cont_4">0100mmmm1nnn1110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1/3               
3     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in banked general register.
Rn_BANK0 is accessed when the RB bit in the SR register is 1, and Rn_BANK1 is
accessed when this bit is 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCRn_BANK (int m)
{
  Rn_BANK = R[m];
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldc.l	@Rm+,Rn_BANK</div>
<div class="col_cont_3">(Rm) -&gt; Rn_BANK, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm1nnn0111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1/5               
1/3   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a source operand in banked general register.
Rn_BANK0 is accessed when the RB bit in the SR register is 1, and Rn_BANK1 is
accessed when this bit is 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDCMRn_BANK (int m)
{
  Rn_BANK = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldre	@(disp,PC)</div>
<div class="col_cont_3">disp*2 + PC -&gt; RE</div>
<div class="col_cont_4">10001110dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            3     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the effective address of the source operand in the repeat end register
RE. The effective address is an address specified by PC + displacement. The PC
is the address four bytes after this instruction. The 8-bit displacement is
sign-extended and doubled. Consequently, the relative interval from the branch
destination is -256 to +254 bytes.
<br><br>

<i><b>Note</b></i><br>The effective address value designated for the RE reregister is different from
the actual repeat end address. Refer to RS and RE Design Rules, for more
information.
<br><br>
When this instruction is arranged immediately after the delayed
branch instruction, PC becomes the "first address +2" of the branch destination.
<br><br>
On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDRE (int d)
{
  long disp;

  if ((d &amp; 0x80) == 0)
    disp = (0x000000FF &amp; (long)d);
  else
    disp = (0xFFFFFF00 | (long)d);

  RE = PC + (disp &lt;&lt; 1);
  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from <instruction a=""> to <instruction b="">
    ...
start:
    <instruction a="">
    ...
    ...
    ...
end:
    <instruction b="">
    ...
</instruction></instruction></instruction></instruction></p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">ldrs	@(disp,PC)</div>
<div class="col_cont_3">disp*2 + PC -&gt; RS</div>
<div class="col_cont_4">10001100dddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            3     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the effective address of the source operand in the repeat start register
RS. The effective address is an address specified by PC + displacement. The PC
is the address four bytes after this instruction. The 8-bit displacement is
sign-extended and doubled. Consequently, the relative interval from the branch
destination is -256 to +254 bytes.
<br><br>

<i><b>Note</b></i><br>When the instructions of the repeat (loop) program are below 3, the effective
address value designated for the RS register is different from the actual repeat
start address. Refer to "RS and RE setting rule", for more information. If this
<br><br>
instruction is arranged immediately after the delayed branch instruction, the PC
becomes "the first address +2" of the branch destination.
<br><br>
On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDRS (int d)
{
  long disp;

  if ((d &amp; 0x80) == 0)
    disp = (0x000000FF &amp; (long)d);
  else
    disp = (0xFFFFFF00 | (long)d);

  RS = PC + (disp &lt;&lt; 1);
  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from <instruction a=""> to <instruction b="">
    ...
start:
    <instruction a="">
    ...
    ...
    ...
end:
    <instruction b="">
    ...
</instruction></instruction></instruction></instruction></p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds	Rm,MACH</div>
<div class="col_cont_3">Rm -&gt; MACH</div>
<div class="col_cont_4">0100mmmm00001010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
3     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the system register MACH.
<br><br>

<i><b>Note</b></i><br>On SH1, only the lower 10 bits are stored in MACH.
<br><br>
On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMACH (int m)
{
  MACH = R[m];

  #if SH1
  if ((MACH &amp; 0x00000200) == 0)
    MACH &amp;= 0x000003FF; 
  else
    MACH |= 0xFFFFFC00;
  #endif

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds.l	@Rm+,MACH</div>
<div class="col_cont_3">(Rm) -&gt; MACH, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00000110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/3   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the system register MACH.
<br><br>

<i><b>Note</b></i><br>On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMMACH (int m)
{
  MACH = Read_32 (R[m]);

  #if SH1
  if ((MACH &amp; 0x00000200) == 0)
    MACH &amp;= 0x000003FF; 
  else
    MACH |= 0xFFFFFC00;
  #endif

  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds	Rm,MACL</div>
<div class="col_cont_3">Rm -&gt; MACL</div>
<div class="col_cont_4">0100mmmm00011010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
3     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the system register MACL.
<br><br>

<i><b>Note</b></i><br>On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMACL (int m)
{
  MACL = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds.l	@Rm+,MACL</div>
<div class="col_cont_3">(Rm) -&gt; MACL, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00010110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/3   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the system register MACL.
<br><br>

<i><b>Note</b></i><br>On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMMACL (int m)
{
  MACL = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds	Rm,PR</div>
<div class="col_cont_3">Rm -&gt; PR</div>
<div class="col_cont_4">0100mmmm00101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">1     1           
1                 
3     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the system register PR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSPR (int m)
{
  PR = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds.l	@Rm+,PR</div>
<div class="col_cont_3">(Rm) -&gt; PR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm00100110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2/3   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the system register PR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMPR (int m)
{
  PR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds	Rm,DSR</div>
<div class="col_cont_3">Rm -&gt; DSR</div>
<div class="col_cont_4">0100mmmm01101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register DSR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSDSR (int m)
{
  DSR = R[m] &amp; 0x0000000F;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds.l	@Rm+,DSR</div>
<div class="col_cont_3">(Rm) -&gt; DSR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01100110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/5   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register DSR.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMDSR (int m)
{
  DSR = Read_32 (R[m]) &amp; 0x0000000F;
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds	Rm,A0</div>
<div class="col_cont_3">Rm -&gt; A0</div>
<div class="col_cont_4">0100mmmm01110110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register A0.  The MSB of the data is
copied into A0G.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSA0 (int m)
{
  A0 = R[m];

  if ((A0 &amp; 0x80000000) == 0)
    A0G = 0x00;
  else
    A0G = 0xFF;

  PC+=2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds.l	@Rm+,A0</div>
<div class="col_cont_3">(Rm) -&gt; A0, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01110110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register A0.  The MSB of the data is
copied into A0G.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMA0 (int m)
{
  A0 = Read_32 (R[m]);

  if ((A0 &amp; 0x80000000) == 0)
    A0G = 0x00;
  else
    A0G = 0xFF;

  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds	Rm,X0</div>
<div class="col_cont_3">Rm -&gt; X0</div>
<div class="col_cont_4">0100mmmm10001010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register X0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSX0 (int m)
{
  X0 = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds.l	@Rm+,X0</div>
<div class="col_cont_3">(Rm) -&gt; X0, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100nnnn10000110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/5   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register X0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMX0 (int m)
{
  X0 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds	Rm,X1</div>
<div class="col_cont_3">Rm -&gt; X1</div>
<div class="col_cont_4">0100mmmm10011010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register X1.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSX1 (int m)
{
  X1 = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds.l	@Rm+,X1</div>
<div class="col_cont_3">(Rm) -&gt; X1, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100nnnn10010110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/5   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register X1.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMX1 (int m)
{
  X1 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds	Rm,Y0</div>
<div class="col_cont_3">Rm -&gt; Y0</div>
<div class="col_cont_4">0100mmmm10101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register Y0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSY0 (int m)
{
  Y0 = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds.l	@Rm+,Y0</div>
<div class="col_cont_3">(Rm) -&gt; Y0, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100nnnn10100110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/5   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register Y0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMY0 (int m)
{
  Y0 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds	Rm,Y1</div>
<div class="col_cont_3">Rm -&gt; Y1</div>
<div class="col_cont_4">0100mmmm10111010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register Y1.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSY1 (int m)
{
  Y1 = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">lds.l	@Rm+,Y1</div>
<div class="col_cont_3">(Rm) -&gt; Y1, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100nnnn10110110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the source operand into the DSP register Y1.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMY1 (int m)
{
  Y1 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">ldtlb</div>
<div class="col_cont_3">PTEH/PTEL -&gt; TLB</div>
<div class="col_cont_4">0000000000111000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1                 
1     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Loads the contents of the PTEH/PTEL registers into the TLB (translation
lookaside buffer) specified by MMUCR.URC (random counter field in the MMC
control register).
<br><br>
LDTLB is a privileged instruction, and can only be used in privileged mode. Use of this
instruction in user mode will cause an illegal instruction exception.
<br><br>

<i><b>Note</b></i><br>As this instruction loads the contents of the PTEH/PTEL registers into a TLB, it
should be used either with the MMU disabled, or in the P1 or P2 virtual space
with the MMU enabled (see the MMU section of the applicable hardware manual for
details).
<br><br>
After this instruction is issued, there must be at least one instruction between
the LDTLB instruction and issuance of an instruction relating to address to the
P0, U0, and P3 areas (i.e. BRAF, BSRF, JMP, JSR, RTS, or RTE).
<br><br>
If the instruction is issued in an exception handler, it should be at least two
instructions prior to an RTE instruction that terminates the handler.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDTLB (void)
{
  #if SH3
  TLB_tag = PTEH;
  TLB_data = PTEL;

  #elif SH4
  TLB[MMUCR.URC].ASID = PTEH &amp; 0x000000FF;
  TLB[MMUCR.URC].VPN = (PTEH &amp; 0xFFFFFC00) &gt;&gt; 10;
  TLB[MMUCR.URC].PPN = (PTEH &amp; 0x1FFFFC00) &gt;&gt; 10;
  TLB[MMUCR.URC].SZ = (PTEL &amp; 0x00000080) &gt;&gt; 6 | (PTEL &amp; 0x00000010) &gt;&gt; 4;
  TLB[MMUCR.URC].SH = (PTEH &amp; 0x00000002) &gt;&gt; 1;
  TLB[MMUCR.URC].PR = (PTEH &amp; 0x00000060) &gt;&gt; 5;
  TLB[MMUCR.URC].WT = (PTEH &amp; 0x00000001);
  TLB[MMUCR.URC].C = (PTEH &amp; 0x00000008) &gt;&gt; 3;
  TLB[MMUCR.URC].D = (PTEH &amp; 0x00000004) &gt;&gt; 2;
  TLB[MMUCR.URC].V = (PTEH &amp; 0x00000100) &gt;&gt; 8;

  #endif

  PC += 2;
}

</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">movca.l	R0,@Rn</div>
<div class="col_cont_3">R0 -&gt; (Rn) (without fetching cache block)</div>
<div class="col_cont_4">0000nnnn11000011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
3-7   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the contents of general register R0 in the memory location indicated by
effective address Rn. This instruction differs from other store instructions as
follows.
<br><br>
If write-back is selected for the accessed memory, and a cache miss occurs, the
cache block will be allocated but an R0 data write will be performed to that
cache block without performing a block read. Other cache block contents are
undefined.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void MOVCAL (int n)
{
  if (is_write_back_memory (R[n]) &amp;&amp; look_up_in_operand_cache (R[n]) == MISS)
    allocate_operand_cache_block (R[n]);

  Write_32 (R[n], R[0]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">nop</div>
<div class="col_cont_3">No operation</div>
<div class="col_cont_4">0000000000001001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
MT    MT          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Note</b></i><br>Increments the program counter (PC), advancing the processing flow to execution
of the next instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void NOP (void)
{
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">ocbi	@Rn</div>
<div class="col_cont_3">Invalidate operand cache block</div>
<div class="col_cont_4">0000nnnn10010011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1-2   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Accesses data using the contents indicated by effective address Rn. In the case
of a hit in the cache, the corresponding cache block is invalidated (the V bit
is cleared to 0). If there is unwritten information (U bit = 1), write-back is
not performed even if write-back mode is selected. No operation is performed in
the case of a cache miss or an access to a non-cache area.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void OCBI (int n)
{
  invalidate_operand_cache_block (R[n]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
Note that the above exceptions are generated even if OCBI does not operate.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">ocbp	@Rn</div>
<div class="col_cont_3">Write back and invalidate operand cache block</div>
<div class="col_cont_4">0000nnnn10100011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1-5   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Accesses data using the contents indicated by effective address Rn. If the cache
is hit and there is unwritten information (U bit = 1), the corresponding cache
block is written back to external memory and that block is invalidated (the V
bit is cleared to 0). If there is no unwritten information (U bit = 0), the
block is simply invalidated. No operation is performed in the case of a cache
miss or an access to a non-cache area.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void OCBP (int n)
{
  if (is_dirty_block (R[n]))
    write_back (R[n])

  invalidate_operand_cache_block (R[n]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
Note that the above exceptions are generated even if OCBP does not operate.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">ocbwb	@Rn</div>
<div class="col_cont_3">Write back operand cache block</div>
<div class="col_cont_4">0000nnnn10110011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1-5   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Accesses data using the contents indicated by effective address Rn. If the cache
is hit and there is unwritten information (U bit = 1), the corresponding cache
block is written back to external memory and that block is cleaned (the U bit
is cleared to 0). In other cases (i.e. in the case of a cache miss or an access
to a non-cache area, or if the block is already clean), no operation is
performed.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void OCBWB (int n)
{
  if (is_dirty_block (R[n]))
    write_back (R[n]);

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
Note that the above exceptions are generated even if OCBWB does not operate.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">pref	@Rn</div>
<div class="col_cont_3">(Rn) -&gt; operand cache</div>
<div class="col_cont_4">0000nnnn10000011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
1                 
1     1     1     </div>
<div class="col_cont_8">                  
1/2               
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>SH4 and SH4A
<br>
Reads a 32-byte data block starting at a 32-byte boundary into the operand
cache. The lower 5 bits of the address specified by Rn are masked to zero.
<br>
This instruction is also used to trigger a Store Queue write-back operation if
the specified address points to the Store Queue area.  For more information
refer to Store Queues in the manual.
<br><br>

SH3 and SH2A
<br>
Reads a 16-byte data block into the cache.  The address specified by Rn should
be on 32-bit boundary.  No address related error is detected in this
instruction. In case of an error, the instruction operates as NOP.
<br><br>

<i><b>Note</b></i><br>On products with no cache, this instruction is handled as a NOP instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void PREF (int n)
{
  prefetch_operand_cache_block (R[n]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">prefi	@Rn</div>
<div class="col_cont_3">Reads 32-byte instruction block into instruction cache</div>
<div class="col_cont_4">0000nnnn11010011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      CO          </div>
<div class="col_cont_7">                  
                  
      13          </div>
<div class="col_cont_8">                  
                  
      10          </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Reads a 32-byte block of data starting at a 32-byte boundary within the
instruction cache. The lower 5 bits of the address specified by Rn are masked
by zeroes.
<br><br>
This instruction does not generate data address error and MMU exceptions. In the
event of an error, the PREFI instruction is treated as an NOP (no operation)
instruction.
<br><br>
When the address to be prefetched is missing from UTLB or is protected, the
PREFI instruction is treated as an NOP instruction and a TLB exception does not
occur.
<br><br>

<i><b>Note</b></i><br>This instruction can be used before the SLEEP command is issued to prefetch
instructions for execution on return from the SLEEP state.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void PREFI (int n)
{
  prefetch_instruction_cache_block (R[n]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">resbank</div>
<div class="col_cont_3">Bank -&gt; R0 to R14, GBR, MACH, MACL, PR</div>
<div class="col_cont_4">0000000001011011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            9/19  </div>
<div class="col_cont_8">                  
                  
            8/20  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Restores the last register saved to a register bank.
<br><br>

<i><b>Note</b></i><br>The issue cycle count is 19 when a bank overflow has occured and the registers
are restored from the stack.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void RESBANK (void)
{
  int m;  // Number of register bank to which a save was last performed.

  if (BO == 0)
  {
    PR = Register_Bank[m].PR_BANK;
    GBR = Register_Bank[m].GBR_BANK;
    MACL = Register_Bank[m].MACL_BANK;
    MACH = Register_Bank[m].MACH_BANK;

    for (int i = 0; i &lt;= 14; i++)
      R[i] = Register_Bank[m].R_BANK[i];
  }
  else
  {
    for (int i = 0; i &lt;= 14; i++)
    {
      R[i] = Read_32 (R[15]);
      R[15] += 4;
    }

    PR = Read_32 (R[15]);
    R[15] += 4;
    GBR = Read_32 (R[15]);
    R[15] += 4;
    MACH = Read_32 (R[15]);
    R[15] += 4;
    MACL = Read_32 (R[15]);
    R[15] += 4;
  }

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">rte</div>
<div class="col_cont_3">Delayed branch
SH1*,SH2*: stack area -&gt; PC/SR
SH3*,SH4*: SSR/SPC -&gt; SR/PC</div>
<div class="col_cont_4">0000000000101011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">1     1           
1                 
5     5     6     </div>
<div class="col_cont_8">4     4           
4                 
5     4     5     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Returns from an exception or interrupt handling routine by restoring the PC and
SR values.  Program execution continues from the address specified
by the restored PC value.
<br><br>
On SH3 and SH4 the PC and SR values are restored from SPC and SSR.  The SR value
accessed by the instruction in the RTE delay slot is the value restored from SSR
by the RTE instruction. The SR and MD values defined prior to RTE execution are
used to fetch the instruction in the RTE delay slot.
<br><br>
On SH1, SH2 and SH2A the PC and SR values are from the stack (R15).
<br><br>

<i><b>Note</b></i><br>As this is a delayed branch instruction, the instruction following the RTE
instruction is executed before the branch destination instruction.
<br><br>
Interrupts are not accepted between this instruction and the following
instruction. An exception must not be generated by the instruction in this
instruction's delay slot. If the following instruction is a branch instruction,
it is identified as a slot illegal instruction.
<br><br>
If this instruction is located in the delay slot immediately following a delayed
branch instruction, it is identified as a slot illegal instruction.
<br><br>
On SH3 and SH4 the SR value accessed by the instruction in the RTE delay slot is
the value restored from SSR by the RTE instruction. The SR and MD values defined
prior to RTE execution are used to fetch the instruction in the RTE delay slot.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void RTE (void)
{
  unsigned long temp = PC;

  #if SH1 || SH2 || SH2A
  PC = Read_32 (R[15]);
  R[15] += 4;
  SR = Read_32 (R[15]) &amp; 0x000063F3;
  R[15] += 4;

  #elif SH3 || SH4 || SH4A
  SR = SSR;
  PC = SPC;

  #endif

  Delay_Slot (temp + 2);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">setrc	Rn</div>
<div class="col_cont_3">Rn[11:0] -&gt; RC (SR[27:16])</div>
<div class="col_cont_4">0100mmmm00010100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            3     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sets the repeat count to the SR register's RC counter. The bottom 12 bits of the
general register Rn are used as the repeat count. 
Set repeat control flags to RF1, RF0 bits of the SR register. Use of the SETRC
instruction is subject to any limitations. Refer to the DSP Repeat (Loop)
Control section of the manual for more information.
<br><img src="./Renesas SH Instruction Set Summary_files/setrc.svg" height="140">
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SETRC (int m)
{
  long temp = (R[m] &amp; 0x00000FFF) &lt;&lt; 16;
  SR &amp;= 0x00000FF3;
  SR |= temp;
  RF1 = Repeat_Control_Flag1;
  RF0 = Repeat_Control_Flag0;
  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  r14       ! Repeat n times from <instruction a=""> to <instruction b="">
    ...
start:
    <instruction a="">
    ...
    ...
    ...
end:
    <instruction b="">
    ...
</instruction></instruction></instruction></instruction></p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">setrc	#imm</div>
<div class="col_cont_3">imm -&gt; RC (SR[23:16]), 0 -&gt; SR[27:24]</div>
<div class="col_cont_4">10000010iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            3     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sets the repeat count to the SR register's RC counter. The 8-bit immediate value
is zero-extended and used as the repeat count. 
Set repeat control flags to RF1, RF0 bits of the SR register. Use of the SETRC
instruction is subject to any limitations. Refer to the DSP Repeat (Loop)
Control section of the manual for more information.
<br><img src="./Renesas SH Instruction Set Summary_files/setrci.svg" height="140">
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SETRCI (int i)
{
  long temp = ((long)i &amp; 0x000000FF) &lt;&lt; 16;
  SR &amp;= 0x00000FFF;
  SR |= temp;
  RF1 = Repeat_Control_Flag1;
  RF0 = Repeat_Control_Flag0;
  PC += 2;
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from <instruction a=""> to <instruction b="">
    ...
start:
    <instruction a="">
    ...
    ...
    ...
end:
    <instruction b="">
    ...
</instruction></instruction></instruction></instruction></p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        </div>
<div class="col_cont_2">sets</div>
<div class="col_cont_3">1 -&gt; S</div>
<div class="col_cont_4">0000000001011000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    EX          </div>
<div class="col_cont_7">                  
1                 
1     1           </div>
<div class="col_cont_8">                  
1                 
1     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sets the S bit to 1.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SETS (void)
{
  S = 1;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sett</div>
<div class="col_cont_3">1 -&gt; T</div>
<div class="col_cont_4">0000000000011000</div>
<div class="col_cont_5">1
</div>
<div class="col_cont_6">                  
                  
MT    EX          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Sets the T bit to 1.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SETT (void)
{
  T = 1;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">sleep</div>
<div class="col_cont_3">Sleep or standby</div>
<div class="col_cont_4">0000000000011011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">1     1           
2                 
4     ud    5     </div>
<div class="col_cont_8">3     3           
4                 
4     ud    0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Places the CPU in the power-down state.
<br><br>
In power-down mode, the CPU retains its internal state, but immediately stops
executing instructions and waits for an interrupt request. When it receives an
interrupt request, the CPU exits the power-down state.
<br><br>
SLEEP is a privileged instruction, and can only be used in privileged mode. Use
of this instruction in user mode will cause an illegal instruction exception.
<br><br>

<i><b>Note</b></i><br>SLEEP performance depends on the standby control register (STBCR). See
Power-Down Modes in the target product's hardware manual, for details.
<br><br>
The number of cycles given is for the transition to sleep mode. "ud" means
the number of cycles is undefined.
<br><br>
Some SH4 implementations have a hardware bug which restricts the instructions
that should follow this instruction for safe operation.  There are two
recommended workarounds:
<li>Put 8 NOP instructions following the SLEEP instruction.</li>
<li>Put 5 "OR R0,R0" instructions following the SLEEP instruction</li>
<br>
For more information see the document "tnsh7456ae.pdf".
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SLEEP (void)
{
  Sleep_standby();
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">stbank	R0,@Rn</div>
<div class="col_cont_3">R0 -&gt; (specified register bank entry)</div>
<div class="col_cont_4">0100nnnn11100001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            7     </div>
<div class="col_cont_8">                  
                  
            6     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>R0 is transferred to the register bank entry indicated by the contents of
general register Rn. The register bank number and register stored in the bank
are specified by general register Rn.
<br><img src="./Renesas SH Instruction Set Summary_files/stbank.svg" height="400">
<br><br>

<i><b>Note</b></i><br>The architecture supports a maximum of 512 banks. However, the number of banks
differs depending on the product.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STBANK (int n)
{
  Write_Bank_32 (R[n], R[0])
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">stc	SR,Rn</div>
<div class="col_cont_3">SR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00000010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">1     1           
1                 
2     1     2     </div>
<div class="col_cont_8">1     1           
1                 
2     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SR in the destination.
<br><br>

<i><b>Note</b></i><br>This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCSR (int n)
{
  R[n] = SR;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">stc.l	SR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, SR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00000011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">1     1           
1                 
2     1     2     </div>
<div class="col_cont_8">2     2           
1/2               
2/2   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SR in the destination.
<br><br>

<i><b>Note</b></i><br>This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">stc	TBR,Rn</div>
<div class="col_cont_3">TBR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01001010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register TBR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCTBR (int n)
{
  R[n] = TBR;
  PC += 2;
}

</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">stc	GBR,Rn</div>
<div class="col_cont_3">GBR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00010010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register GBR in the destination.
<br><br>

<i><b>Note</b></i><br>This instruction can also be issued in user mode. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">STCGBR (int n)
{
  R[n] = GBR;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">stc.l	GBR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, GBR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00010011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">2     2           
1/2               
2/2   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register GBR in the destination.
<br><br>

<i><b>Note</b></i><br>This instruction can also be issued in user mode. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMGBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], GBR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">stc	VBR,Rn</div>
<div class="col_cont_3">VBR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00100010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register VBR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCVBR (int n)
{
  R[n] = VBR;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  
Privileged</div>
<div class="col_cont_2">stc.l	VBR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, VBR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00100011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">2     2           
1/2               
2/2   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register VBR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMVBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], VBR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">stc	MOD,Rn</div>
<div class="col_cont_3">MOD -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01010010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register MOD in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMOD (int n)
{
  R[n] = MOD;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">stc.l	MOD,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, MOD -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01010011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/2   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register MOD in the destination.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMMOD (int n)
{
  R[n] -= 4;
  Write_32 (R[n], MOD);
  PC += 2;
}

</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">stc	RE,Rn</div>
<div class="col_cont_3">RE -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01110010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register RE in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCRE (int n)
{
  R[n] = RE;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">stc.l	RE,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, RE -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01110011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/2   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register RE in the destination.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMRE (int n)
{
  R[n] -= 4;
  Write_32 (R[n], RE);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">stc	RS,Rn</div>
<div class="col_cont_3">RS -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01100010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register RS in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCRS (int n)
{
  R[n] = RS;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">stc.l	RS,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, RS -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01100011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1/2   
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register RS in the destination.
<br><br>

<i><b>Note</b></i><br>On the SH-DSP the latency of this instruction is 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMRS (int n)
{
  R[n] -= 4;
  Write_32 (R[n], RS);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc	SGR,Rn</div>
<div class="col_cont_3">SGR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00111010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
                  
3     1           </div>
<div class="col_cont_8">                  
                  
3     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SGR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCSGR (int n)
{
  R[n] = SGR;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc.l	SGR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, SGR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00110010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
                  
3     1           </div>
<div class="col_cont_8">                  
                  
3/3   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SGR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMSGR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SGR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc	SSR,Rn</div>
<div class="col_cont_3">SSR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00110010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
2     1           </div>
<div class="col_cont_8">                  
1                 
2     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SSR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCSSR (int n)
{
  R[n] = SSR;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc.l	SSR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, SSR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00110011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
2     1           </div>
<div class="col_cont_8">                  
1/2               
2     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SSR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMSSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SSR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc	SPC,Rn</div>
<div class="col_cont_3">SPC -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01000010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
2     1           </div>
<div class="col_cont_8">                  
1                 
2     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SPC in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCSPC (int n)
{
  R[n] = SPC;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc.l	SPC,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, SPC -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01000011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
                  
2     1           </div>
<div class="col_cont_8">                  
                  
2/2   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register SPC in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMSPC (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SPC);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc	DBR,Rn</div>
<div class="col_cont_3">DBR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn11111010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
                  
2     1           </div>
<div class="col_cont_8">                  
                  
2     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register DBR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCDBR (int n)
{
  R[n] = DBR;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc.l	DBR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, DBR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn11110010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
                  
2     1           </div>
<div class="col_cont_8">                  
                  
2/2   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores control register DBR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMDBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], DBR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc	Rm_BANK,Rn</div>
<div class="col_cont_3">Rm_BANK -&gt; Rn (m = 0-7)</div>
<div class="col_cont_4">0000nnnn1mmm0010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
1                 
2     1           </div>
<div class="col_cont_8">                  
1                 
2     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a banked general register in the destination. Rn_BANK0 is accessed when
the RB bit in the SR register is 1, and Rn_BANK1 is accessed when this bit is 0. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCRm_BANK (int n)
{
  R[n] = Rm_BANK;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
SH3               
SH4   SH4A        
Privileged</div>
<div class="col_cont_2">stc.l	Rm_BANK,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, Rm_BANK -&gt; (Rn) (m = 0-7)</div>
<div class="col_cont_4">0100nnnn1mmm0011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">                  
2                 
2     1           </div>
<div class="col_cont_8">                  
2                 
2/2   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores a banked general register in the destination. Rn_BANK0 is accessed when
the RB bit in the SR register is 1, and Rn_BANK1 is accessed when this bit is 0. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STCMRm_BANK (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Rm_BANK);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<li>General illegal instruction exception</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts	MACH,Rn</div>
<div class="col_cont_3">MACH -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00001010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores system register MACH in the destination.
<br><br>

<i><b>Note</b></i><br>On SH1, the value of bit 9 is transferred to and stored in the higher 22 bits
(bits 31 to 10) of the destination.
<br><br>
On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMACH (int n)
{
  R[n] = MACH;

  #if SH1
  if ((R[n] &amp; 0x00000200) == 0)
    R[n] &amp;= 0x000003FF; 
  else
    R[n] |= 0xFFFFFC00;

  #endif

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts.l	MACH,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, MACH -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00000010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/1   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores system register MACH in the destination.
<br><br>

<i><b>Note</b></i><br>On SH1, the value of bit 9 is transferred to and stored in the higher 22 bits
(bits 31 to 10) of the destination.
<br><br>
On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMMACH (int n)
{
  R[n] -= 4;

  #if SH1
  if ((MACH &amp; 0x00000200) == 0)
    Write_32 (R[n], MACH &amp; 0x000003FF);
  else
    Write_32 (R[n], MACH | 0xFFFFFC00)

  #else
  Write_32 (R[n], MACH);

  #endif

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts	MACL,Rn</div>
<div class="col_cont_3">MACL -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00011010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores system register MACL in the destination.
<br><br>

<i><b>Note</b></i><br>On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMACL (int n)
{
  R[n] = MACL;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts.l	MACL,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, MACL -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00010010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
1     1     1     </div>
<div class="col_cont_8">1     1           
1                 
1/1   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores system register MACL in the destination.
<br><br>

<i><b>Note</b></i><br>On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMMACL (int n)
{
  R[n] -= 4;
  Write_32 (R[n], MACL);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts	PR,Rn</div>
<div class="col_cont_3">PR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn00101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores system register PR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSPR (int n)
{
  R[n] = PR;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts.l	PR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, PR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn00100010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">1     1           
1                 
2     1     1     </div>
<div class="col_cont_8">1     1           
1                 
2/2   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores system register PR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMPR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], PR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Initial page write exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts	DSR,Rn</div>
<div class="col_cont_3">DSR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register DSR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSDSR (int n)
{
  R[n] = DSR;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts.l	DSR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, DSR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01100010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register DSR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMDSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], DSR);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts	A0,Rn</div>
<div class="col_cont_3">A0 -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01111010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register A0 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSA0 (int n)
{
  R[n] = A0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts.l	A0,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, A0 -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01100010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register A0 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMA0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], A0);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts	X0,Rn</div>
<div class="col_cont_3">X0 -&gt; Rn</div>
<div class="col_cont_4">0000nnnn10001010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register X0 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSX0 (int n)
{
  R[n] = X0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts.l	X0,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, X0 -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn10000010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register X0 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMX0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], X0);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts	X1,Rn</div>
<div class="col_cont_3">X1 -&gt; Rn</div>
<div class="col_cont_4">0000nnnn10011010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register X1 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSX1 (int n)
{
  R[n] = X1;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts.l	X1,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, X1 -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn10010010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register X1 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMX1 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], X1);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts	Y0,Rn</div>
<div class="col_cont_3">Y0 -&gt; Rn</div>
<div class="col_cont_4">0000nnnn10101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register Y0 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSY0 (int n)
{
  R[n] = Y0;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts.l	Y0,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, Y0 -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn10100010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register Y0 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMY0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Y0);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts	Y1,Rn</div>
<div class="col_cont_3">Y1 -&gt; Rn</div>
<div class="col_cont_4">0000nnnn10111010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register Y1 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSY1 (int n)
{
  R[n] = Y1;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">sts.l	Y1,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, Y1 -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn10110010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores DSP register Y1 in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMY1 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Y1);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">synco</div>
<div class="col_cont_3">Prevents the next instruction from being issued until instructions issued before this instruction has been completed.</div>
<div class="col_cont_4">0000000010101011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      CO          </div>
<div class="col_cont_7">                  
                  
      ud          </div>
<div class="col_cont_8">                  
                  
      ud          </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>This instruction is used to synchronize data operations. When this instruction
is executed, the subsequent bus accesses are not executed until the execution of
all preceding bus accesses has been completed.
<br><br>

<i><b>Note</b></i><br>The SYNCO instruction can not guarantee the ordering of receipt timing which is
notified by the memory-mapped peripheral resources through the method except bus
when the register is changed by bus accesses. Refer to the description of each
registers to guarantee this ordering.
<br><br>
Common example usages are:
<li>Ordering access to memory areas which are shared with other memory users</li>
<li>Flushing all write buffers</li>
<li>Stopping memory-access operations from merging and becoming ineffective</li>
<li>Waiting for the completion of cache-control instructions</li>
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void SYNCO (void)
{
  synchronize_data_operaiton ();
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">SH1   SH2         
SH3               
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">trapa	#imm</div>
<div class="col_cont_3">SH1*,SH2*: PC/SR -&gt; stack area, (imm*4 + VBR) -&gt; PC
SH3*,SH4*: PC/SR -&gt; SPC/SSR, imm*4 -&gt; TRA, 0x160 -&gt; EXPEVT, VBR + 0x0100 -&gt; PC</div>
<div class="col_cont_4">11000011iiiiiiii</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    CO          </div>
<div class="col_cont_7">2     2           
2                 
7     14    5     </div>
<div class="col_cont_8">8     8           
8                 
7     13    6     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Starts trap exception handling.

SH1, SH2 and SH2A:
<br>
The PC and SR values are stored on the stack, and the program branches to an
address specified by the vector. The vector is a memory address obtained by
zero-extending the 8-bit immediate data and then quadrupling it. The PC is the
start address of the next instruction. TRAPA and RTE are both used together for
system calls.
<br><br>

SH3, SH4 and SH4A:
<br>
The values of (PC + 2), SR, and R15 are saved to SPC, SSR and SGR, and 8-bit
immediate data is stored in the TRA register (bits 9 to 2). The processor mode
is switched to privileged mode (the MD bit in SR is set to 1), and the BL bit
and RB bit in SR are set to 1.  As a result, exception and interrupt requests
are masked (not accepted), and the BANK1 registers (R0_BANK1 to R7_BANK1) are
selected. Exception code 0x160 is written to the EXPEVT register (bits 11 to 0).
The program branches to address (VBR + 0x00000100), indicated by the sum of the
VBR register contents and offset 0x00000100.
<br><br>

<i><b>Note</b></i><br>Some SH4 implementations have a hardware bug which restricts the instructions
that should follow this instruction for safe operation.  There are two
recommended workarounds:
<li>Put 8 NOP instructions following the TRAPA instruction.</li>
<li>Put 5 "OR R0,R0" instructions following the TRAPA instruction</li>
<br>
For more information see the document "tnsh7456ae.pdf".
<br><br>
Some SH2E implementations (SH7055) have an FPU related hardware bug which
affects this instruction.  The recommended workaround is to align the addresses
of trapa handlers to 4 bytes and not to place any FPU or FPU related
instructions at addresses 4n + 2 in the handler.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void TRAPA (int i)
{
  int imm = (0x000000FF &amp; i);

  #if SH1 || SH2 || SH2A
  R[15] -= 4;
  Write_32 (R[15], SR);
  R[15] -= 4;
  Write_32 (R[15], PC + 2);
  PC = Read_32 (VBR + (imm &lt;&lt; 2));

  #elif SH3 || SH4 || SH4A
  TRA = imm &lt;&lt; 2;
  SSR = SR;
  SPC = PC + 2;
  SGR = R15;
  SR.MD = 1;
  SR.BL = 1;
  SR.RB = 1;
  EXPEVT = 0x00000160;
  PC = VBR + 0x00000100;

  #endif
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Unconditional trap</li>
<li>Slot illegal instruction exception</li>
<br><br>

</div></div>
<br><b>32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov	FRm,FRn</div>
<div class="col_cont_3">FRm -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm1100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers FRm contents to FRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV (int m, int n)
{
  FR[n] = FR[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.s	@Rm,FRn</div>
<div class="col_cont_3">(Rm) -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm1000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
2     1     0/2   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by Rm to FRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_LOAD (int m, int n)
{
  FR[n] = Read_32 (R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.s	FRm,@Rn</div>
<div class="col_cont_3">FRm -&gt; (Rn)</div>
<div class="col_cont_4">1111nnnnmmmm1010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers FRm contents to memory at address indicated by Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_STORE (int m, int n)
{
  Write_32 (R[n], FR[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.s	@Rm+,FRn</div>
<div class="col_cont_3">(Rm) -&gt; FRn, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">1111nnnnmmmm1001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1/2   1     1/2   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by Rm to FRn, and adds 4 to
Rm.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_RESTORE (int m, int n)
{
  FR[n] = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.s	FRm,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, FRm -&gt; (Rn)</div>
<div class="col_cont_4">1111nnnnmmmm1011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1/1   1     1/0   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts 4 from Rn, and transfers FRm contents to memory at address indicated
by resulting Rn value.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_SAVE (int m, int n)
{
  Write_32 (R[n] - 4, FR[m]);
  R[n] -= 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.s	@(R0,Rm),FRn</div>
<div class="col_cont_3">(R0 + Rm) -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm0110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
2     1     0/2   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by (R0 + Rm) to FRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_LOAD (int m, int n)
{
  FR[n] = Read_32 (R[0] + R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.s	FRm,@(R0,Rn)</div>
<div class="col_cont_3">FRm -&gt; (R0 + Rn)</div>
<div class="col_cont_4">1111nnnnmmmm0111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers FRm contents to memory at address indicated by (R0 + Rn).
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_STORE (int m, int n)
{
  Write_32 (R[0] + R[n], FR[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">fmov.s	@(disp12,Rm),FRn</div>
<div class="col_cont_3">(disp*4 + Rm) -&gt; FRn</div>
<div class="col_cont_4">0011nnnnmmmm0001 0111dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            0/2   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers memory contents at the address indicated by (disp + Rn) to FRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_DISP12_LOAD (int m, int n, int d)
{
  long disp = (0x00000FFF &amp; (long)d);
  FR[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">fmov.s	FRm,@(disp12,Rn)</div>
<div class="col_cont_3">FRm -&gt; (disp*4 + Rn)</div>
<div class="col_cont_4">0011nnnnmmmm0001 0011dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            1     </div>
<div class="col_cont_8">                  
                  
            0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers FRm contents to memory at the address indicated by (disp + Rn).
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_DISP12_STORE (int m, int n, int d)
{
  long disp = (0x00000FFF &amp; (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), FR[m]);
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<br><b>64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov	DRm,DRn</div>
<div class="col_cont_3">DRm -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmm01100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     2     </div>
<div class="col_cont_8">                  
                  
0     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers DRm contents to DRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = DR[m &gt;&gt; 1];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov	DRm,XDn</div>
<div class="col_cont_3">DRm -&gt; XDn</div>
<div class="col_cont_4">1111nnn1mmm01100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
0     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers DRm contents to XDn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_DRXD (int m, int n)
{
  XD[n &gt;&gt; 1] = DR[m &gt;&gt; 1];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov	XDm,DRn</div>
<div class="col_cont_3">XDm -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmm11100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
0     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers XDm contents to DRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_XDDR (int m, int n)
{
  DR[n &gt;&gt; 1] = XD[m &gt;&gt; 1];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov	XDm,XDn</div>
<div class="col_cont_3">XDm -&gt; XDn</div>
<div class="col_cont_4">1111nnn1mmm11100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
0     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers XDm contents to XDn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_XDXD (int m, int n)
{
  XD[n &gt;&gt; 1] = XD[m &gt;&gt; 1];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.d	@Rm,DRn</div>
<div class="col_cont_3">(Rm) -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmmm1000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     2     </div>
<div class="col_cont_8">                  
                  
2     1     0/4   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by Rm to DRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_LOAD_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov.d	@Rm,XDn</div>
<div class="col_cont_3">(Rm) -&gt; XDn</div>
<div class="col_cont_4">1111nnn1mmmm1000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
2     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by Rm to XDn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_LOAD_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.d	DRm,@Rn</div>
<div class="col_cont_3">DRm -&gt; (Rn)</div>
<div class="col_cont_4">1111nnnnmmm01010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     2     </div>
<div class="col_cont_8">                  
                  
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers DRm contents to memory at address indicated by Rn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_STORE_DR (int m, int n)
{
  Write_64 (R[n], DR[m &gt;&gt; 1]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov.d	XDm,@Rn</div>
<div class="col_cont_3">XDm -&gt; (Rn)</div>
<div class="col_cont_4">1111nnnnmmm11010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by (R0 + Rm) to XDn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_STORE_XD (int m, int n)
{
  Write_64 (R[n], XD[m &gt;&gt; 1]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.d	@Rm+,DRn</div>
<div class="col_cont_3">(Rm) -&gt; DRn, Rm + 8 -&gt; Rm</div>
<div class="col_cont_4">1111nnn0mmmm1001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     2     </div>
<div class="col_cont_8">                  
                  
1/2   1     1/4   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by Rm to DRn, and adds 8 to
Rm.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_RESTORE_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[m]);
  R[m] += 8;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov.d	@Rm+,XDn</div>
<div class="col_cont_3">(Rm) -&gt; XDn, Rm+8 -&gt; Rm</div>
<div class="col_cont_4">1111nnn1mmmm1001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1/2   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by Rm to XDn, and adds 8 to
Rm.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_RESTORE_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[m]);
  R[m] += 8;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.d	DRm,@-Rn</div>
<div class="col_cont_3">Rn-8 -&gt; Rn, DRm -&gt; (Rn)</div>
<div class="col_cont_4">1111nnnnmmm01011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     2     </div>
<div class="col_cont_8">                  
                  
1/1   1     0/1   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts 8 from Rn, and transfers DRm contents to memory at address indicated
by resulting Rn value.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_SAVE_DR (int m, int n)
{
  Write_64 (R[n] - 8, DR[m &gt;&gt; 1]);
  R[n] -= 8;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov.d	XDm,@-Rn</div>
<div class="col_cont_3">Rn-8 -&gt; Rn, (Rn) -&gt; XDm</div>
<div class="col_cont_4">1111nnnnmmm11011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1/1   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts 8 from Rn, and transfers XDm contents to memory at address indicated
by resulting Rn value.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_SAVE_XD (int m, int n)
{
  Write_64 (R[n] - 8, XD[m &gt;&gt; 1]);
  R[n] -= 8;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.d	@(R0,Rm),DRn</div>
<div class="col_cont_3">(R0 + Rm) -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmmm0110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     2     </div>
<div class="col_cont_8">                  
                  
2     1     0/4   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by (R0 + Rm) to DRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_LOAD_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov.d	@(R0,Rm),XDn</div>
<div class="col_cont_3">(R0 + Rm) -&gt; XDn</div>
<div class="col_cont_4">1111nnn1mmmm0110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
2     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers contents of memory at address indicated by (R0 + Rm) to XDn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_LOAD_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmov.d	DRm,@(R0,Rn)</div>
<div class="col_cont_3">DRm -&gt; (R0 + Rn)</div>
<div class="col_cont_4">1111nnnnmmm00111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     2     </div>
<div class="col_cont_8">                  
                  
1     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers DRm contents to memory at address indicated by (R0 + Rn).
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_STORE_DR (int m, int n)
{
  Write_64 (R[0] + R[n], DR[m &gt;&gt; 1]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fmov.d	XDm,@(R0,Rn)</div>
<div class="col_cont_3">XDm -&gt; (R0 + Rn)</div>
<div class="col_cont_4">1111nnnnmmm10111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1     1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers XDm contents to memory at address indicated by (R0 + Rn).
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_STORE_XD (int m, int n)
{
  Write_64 (R[0] + R[n], XD[m &gt;&gt; 1]);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">fmov.d	@(disp12,Rm),DRn</div>
<div class="col_cont_3">(disp*8 + Rm) -&gt; DRn</div>
<div class="col_cont_4">0011nnn0mmmm0001 0111dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            2     </div>
<div class="col_cont_8">                  
                  
            0/4   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers memory contents at the address indicated by (disp + Rn) to DRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_DISP12_LOAD_DR (int m, int n, int d)
{
  long disp = (0x00000FFF &amp; (long)d);
  DR[n &gt;&gt; 1] = Read_64 (R[m] + (disp &lt;&lt; 3));
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
            SH2A  </div>
<div class="col_cont_2">fmov.d	DRm,@(disp12,Rn)</div>
<div class="col_cont_3">DRm -&gt; (disp*8 + Rn)</div>
<div class="col_cont_4">0011nnnnmmm00001 0011dddddddddddd</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
                  
            2     </div>
<div class="col_cont_8">                  
                  
            0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers DRm contents to memory at the address indicated by (disp + Rn).
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMOV_INDEX_DISP12_STORE_DR (int m, int n, int d)
{
  long disp = (0x00000FFF &amp; (long)d);
  Write_64 (R[n] + (disp &lt;&lt; 3), DR[m &gt;&gt; 1]);
  PC += 4;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<br><b>Floating-Point Single-Precision Instructions (FPSCR.PR = 0)</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fldi0	FRn</div>
<div class="col_cont_3">0x00000000 -&gt; FRn</div>
<div class="col_cont_4">1111nnnn10001101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>When FPSCR.PR = 0, this instruction loads floating-point 0.0 (0x00000000) into
FRn.<br>
If FPSCR.PR = 1, the instruction is handled as an illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FLDI0 (int n)
{
  FR[n] = 0x00000000;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fldi1	FRn</div>
<div class="col_cont_3">0x3F800000 -&gt; FRn</div>
<div class="col_cont_4">1111nnnn10011101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>When FPSCR.PR = 0, this instruction loads floating-point 1.0 (0x3F800000) into
FRn.<br>
If FPCSR.PR = 1, the instruction is handled as an illegal instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FLDI1 (int n)
{
  FR[n] = 0x3F800000;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">flds	FRm,FPUL</div>
<div class="col_cont_3">FRm -&gt; FPUL</div>
<div class="col_cont_4">1111mmmm00011101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the contents of floating-point register FRm into system register FPUL.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FLDS (int m)
{
  FPUL = FR[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fsts	FPUL,FRn</div>
<div class="col_cont_3">FPUL -&gt; FRn</div>
<div class="col_cont_4">1111nnnn00001101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the contents of system register FPUL to floating-point register FRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSTS (int n)
{
  FR[n] = FPUL;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fabs	FRn</div>
<div class="col_cont_3">FRn &amp; 0x7FFFFFFF -&gt; FRn</div>
<div class="col_cont_4">1111nnnn01011101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears the most significant bit of the contents of floating-point register FRn
to 0, and stores the result in FRn.
<br><br>

<i><b>Note</b></i><br>The cause and flag fields in FPSCR are not updated.
<br><br>
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FABS (int n)
{
  FR[n] = FR[n] &amp; 0x7FFFFFFFF;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fneg	FRn</div>
<div class="col_cont_3">FRn ^ 0x80000000 -&gt; FRn</div>
<div class="col_cont_4">1111nnnn01001101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Inverts the most significant bit (sign bit) of the contents of floating-point
register FRn, and stores the result in FRn.
<br><br>

<i><b>Note</b></i><br>The cause and flag fields in FPSCR are not updated.
<br><br>
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FNEG (int n)
{
  FR[n] = -FR[n];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fadd	FRm,FRn</div>
<div class="col_cont_3">FRn + FRm -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm0000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3/4   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically adds the two single-precision floating-point numbers in FRn and
FRm, and stores the result in FRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fadd.svg" height="300">
<br><br>

<i><b>Note</b></i><br>SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FADD (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, ADD);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        break;
      default:
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case NZERO:
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;

     case NINF:
       switch (data_type_of (n))
       {
       case PINF:
         invalid (n);
         break;
       default:
         inf (n, 1);
         break;
       }
       break;
    }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>

<li>Overflow
<br>
Generation of overflow-exception traps
<br>
FRn and FRm have the same sign and the exponent of at least one value is 0xFE
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
FRn and FRm have different signs and neither has an exponent greater than 0x18
</li>

<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fsub	FRm,FRn</div>
<div class="col_cont_3">FRn - FRm -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm0001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3/4   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically subtracts the single-precision floating-point number in FRm from
the single-precision floating-point number in FRn, and stores the result in FRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fsub.svg" height="300">
<br><br>

<i><b>Note</b></i><br>SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSUB (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, SUB);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        FR[n] = -FR[n];
        break;
      default:
        break;
      }
      break;

    case PZERO:
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case PINF:
        invalid (n);
        break;
      default:
        inf (n, 1);
        break;
      }
      break;

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;
    }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>

<li>Overflow
<br>
Generation of overflow-exception traps
<br>
FRn and FRm have the same sign and the exponent of at least one value is 0xFE
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
FRn and FRm have different signs and neither has an exponent greater than 0x18
</li>

<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmul	FRm,FRn</div>
<div class="col_cont_3">FRn * FRm -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm0010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3/4   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically multiplies the two single-precision floating-point numbers in
FRn and FRm, and stores the result in FRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fmul.svg" height="300">
<br><br>

<i><b>Note</b></i><br>SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMUL (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      default:
        normal_fmul (m, n);
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        invalid (n);
        break;
      default: 
        zero (n,sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      default:
        inf (n, sign_of (m) ^ sign_of (n));
        break
      }
      break;
    }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>

<li>Overflow
<br>
Generation of overflow-exception traps
<br>
(exponent of FRn) + (exponent of FRm) - 0x7F is not less than 0xFE
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
When both FRn and FRm are normalized numbers:
(exponent of FRn) + (exponent of FRm) - 0x7F is not more than 0x00
<br>
When at least FRn or FRm is not a normalized number:
(exponent of FRn) + (exponent of FRm) - 0x7F is not more than 0x18
</li>

<li>Inexact</li>

<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmac	FR0,FRm,FRn</div>
<div class="col_cont_3">FR0 * FRm + FRn -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm1110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3/4   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically multiplies the two single-precision floating-point numbers in
FR0 and FRm, arithmetically adds the contents of FRn, and stores the result in
FRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fmac.svg" height="942">
<br><br>

<i><b>Note</b></i><br>SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br><br>
This instruction rounds only the final result and does not round the
intermediate result of the multiplication.  Thus, for IEEE 754 compliant code,
this instruction cannot be used as a replacement for individual FADD and FMUL
instructions.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMAC (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (FPSCR_PR == 1)
    undefined_operation ();

  else if (data_type_of (0) == sNaN
           || data_type_of (m) == sNaN
           || data_type_of (n) == sNaN)
    invalid (n);

  else if (data_type_of (0) == qNaN || data_type_of (m) == qNaN)
    qnan (n);

  else if (data_type_of (0) == DENORM || data_type_of (m) == DENORM)
    set_E ();

  else
    switch (data_type_of (0))
    {
    case NORM:
      switch (data_type_of (m))
      {
      case PZERO:
      case NZERO:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PZERO:
        case NZERO:
          zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
          break;
        default:
          break;
        }

      case PINF:
      case NINF:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PINF:
        case NINF:
          if (sign_of (0) ^ sign_of (m) ^ sign_of (n))
            invalid (n);
          else
            inf (n, sign_of (0) ^ sign_of (m));
          break;
        default:
          inf (n, sign_of (0) ^ sign_of (m));
          break;
        }

      case NORM:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PINF:
        case NINF:
          inf (n, sign_of (n));
          break;
        case PZERO:
        case NZERO:
        case NORM:
          normal_fmac (m, n);
          break;
        }
        break;

      case PZERO:
      case NZERO:
        switch (data_type_of (m))
        {
        case PINF:
        case NINF:
          invalid (n);
          break;
        case PZERO:
        case NZERO:
        case NORM:
          switch (data_type_of (n))
          {
          case DENORM:
            set_E ();
            break;
          case qNaN:
            qnan (n);
            break;
          case PZERO:
          case NZERO:
            zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
            break;
          default:
            break;
          }
          break;
        }
        break;

      case PINF:
      case NINF:
        switch (data_type_of (m))
        {
        case PZERO:
        case NZERO:
          invalid (n);
          break;
        default:
          switch (data_type_of (n))
          {
          case DENORM:
            set_E ();
            break;
          case qNaN:
            qnan(n);
            break;
          default:
            inf (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
            break
          }
          break;
        }
        break;
      }
    }
}

void normal_fmac (int m, int n)
{
  union
  {
    int double x;
    int l[4];
  } dstx, tmpx;

  float dstf, srcf;

  if (data_type_of (n) == PZERO || data_type_of (n) == NZERO)
    srcf = 0.0; // flush denormalized value
  else
    srcf = FR[n];

  tmpx.x = FR[0]; // convert single to int double
  tmpx.x *= FR[m]; //exact product
  dstx.x = tmpx.x + srcf;

  if ((dstx.x == srcf &amp;&amp; tmpx.x != 0.0)
      || (dstx.x == tmpx.x &amp;&amp; srcf != 0.0))
  {
    set_I ();
    if (sign_of (0) ^ sign_of (m) ^ sign_of (n))
    {
      dstx.l[3] -= 1; // correct result
      if (dstx.l[3] == 0xFFFFFFFF)
        dstx.l[2] -= 1;
      if (dstx.l[2] == 0xFFFFFFFF)
        dstx.l[1] -= 1;
      if (dstx.l[1] == 0xFFFFFFFF)
        dstx.l[0] -= 1;
    }
    else
      dstx.l[3] |= 1
  }

  if ((dstx.l[1] &amp; 0x01FFFFFF) || dstx.l[2] || dstx.l[3])
    set_I();

  if(FPSCR_RM == 1)
  {
    dstx.l[1] &amp;= 0xFE000000; // round toward zero
    dstx.l[2] = 0x00000000;
    dstx.l[3] = 0x00000000;
  }

  dstf = dstx.x;
  check_single_exception (&amp;FR[n], dstf);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>

<li>Overflow
<br>
Generation of overflow-exception traps
<br>
At least one of the following results is not less than 0xFD:
<br>
(exponent of FR0) + (exponent of FRm)
<br>
(exponent of FRn)
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
At least one of the following results is not more than 0x2E:
<br>
(exponent of FR0) + (exponent of FRm)
<br>
(exponent of FRn)
</li>

<li>Inexact</li>

<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fdiv	FRm,FRn</div>
<div class="col_cont_3">FRn / FRm -&gt; FRn</div>
<div class="col_cont_4">1111nnnnmmmm0011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            13    
      13          
12/13 14    12    </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically divides the single-precision floating-point number in FRn by the
single-precision floating-point number in FRm, and stores the result in FRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fdiv.svg" height="300">
<br><br>

<i><b>Note</b></i><br>SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FDIV (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case DENORM:
        set_E ();
        break;
      default:
        normal_fdiv_single (m, n);
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
      case NINF:
        break;
      default:
        dz (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
        inf (n, 1);
        break;
      case NINF:
        inf (n, 0);
        break;
      default:
        dz (FR[n], sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case DENORM:
      set_E ();
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case DENORM:
        set_E ();
        break;
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;
    }
}

void normal_fdiv_single (int m, int n)
{
  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } tmpd;

  tmpf.f = FR[n];   // save destination value
  dstf.f /= FR[m];  // round toward nearest or even
  tmpd.d = dstf.f;  // convert single to double
  tmpd.d *= FR[m];

  if (tmpf.f != tmpd.d)
    set_I ();
  if (tmpf.f &lt; tmpd.d &amp;&amp; FPSCR_RM == 1)
    dstf.l -= 1; // round toward zero

  check_single_exception (&amp;FR[n], dstf.f);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>
<li>Division by zero</li>
<li>Overflow
<br>
Generation of overflow-exception traps
<br>
(exponent of FRn) - (exponent of FRm) + 0x7F is not less than 0xFF
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
(exponent of FRn) - (exponent of FRm) + 0x7F is not more than 0x01
</li>

<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fsqrt	FRn</div>
<div class="col_cont_3">sqrt (FRn) -&gt; FRn</div>
<div class="col_cont_4">1111nnnn01101101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
      1           
1     1     1     </div>
<div class="col_cont_8">                  
      13          
11/12 30    11    </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds the arithmetical square root of the single-precision floating-point number
in FRn, and stores the result in FRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in FPSCR.cause and FPSCR.flag and FRn is not
updated. Appropriate processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fsqrt.svg" height="128">
<br><br>

<i><b>Note</b></i><br>SH3E supports only invalid operation (V) and division by zero
(Z) exception flags.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSQRT (int n)
{
  PC += 2;
  clear_cause ();

  switch (data_type_of (n))
  {
  case NORM:
    if (sign_of (n) == 0)
      normal_fsqrt_single (n);
    else
      invalid (n);
    break;

  case DENORM:
    if (sign_of (n) == 0)
      set_E ();
    else
      invalid (n);
    break;

  case PZERO:
  case NZERO:
  case PINF:
    break;

  case NINF:
    invalid (n);
    break;

  case qNAN:
    qnan (n);
    break;

  case sNAN:
    invalid (n);
    break;
  }
}

void normal_fsqrt_single (int n)
{
  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } tmpd;

  tmpf.f = FR[n];         // save destination value
  dstf.f = sqrt (FR[n]);  // round toward nearest or even
  tmpd.d = dstf.f;        // convert single to double
  tmpd.d *= dstf.f;

  if (tmpf.f != tmpd.d)
    set_I ();
  if (tmpf.f &lt; tmpd.d &amp;&amp; FPSCR_RM == 1)
    dstf.l -= 1;  // round toward zero
  if (FPSCR &amp; ENABLE_I)
    fpu_exception_trap ();
  else
    FR[n] = dstf.f;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>
<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fcmp/eq	FRm,FRn</div>
<div class="col_cont_3">If FRn = FRm: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">1111nnnnmmmm0100</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
2/4   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically compares the two single-precision floating-point numbers in FRn
and FRm, and stores 1 in the T bit if they are equal, or 0 otherwise.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fcmpeq.svg" height="300">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FCMP_EQ (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_single (m, n) == INVALID)
    fcmp_invalid ();
  else if (fcmp_chk_single (m, n) == EQ)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_single (int m, int n)
{
  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    return INVALID;
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    return UO;
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
        return GT;
      case NINF:
        return LT;
      default:
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        return EQ;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
        case PINF:
          return EQ;
        default:
          return LT;
      }

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        return EQ;
      default:
        return GT;
      }
    }

  if (FR[n] == FR[m])
    return EQ;
  else if (FR[n] &gt; FR[m])
    return GT;
  else
    return LT;
}

void fcmp_invalid (void)
{
  set_V ();

  if ((FPSCR &amp; ENABLE_V) == 0)
    T = 0;
  else
    fpu_exception_trap ();
}

</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fcmp/gt	FRm,FRn</div>
<div class="col_cont_3">If FRn &gt; FRm: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">1111nnnnmmmm0101</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
2/4   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically compares the two single-precision floating-point numbers in FRn
and FRm, and stores 1 in the T bit if FRn &gt; FRm, or 0 otherwise.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fcmpgt.svg" height="300">
<br><br>

<i><b>Note</b></i><br>For IEEE 754 conform less-than-or-equal comparison it is not sufficient to swap
the operands.  The FCMP/EQ must be used as well.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FCMP_GT (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_single (m, n) == INVALID || fcmp_chk_single (m, n) == UO)
    fcmp_invalid ();
  else if (fcmp_chk_single (m, n) == GT)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_single (int m, int n)
{
  // see description of FCMP/EQ instruction.
}

void fcmp_invalid (void)
{
  // see description of FCMP/EQ instruction.
}

</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">float	FPUL,FRn</div>
<div class="col_cont_3">(float)FPUL -&gt; FRn</div>
<div class="col_cont_4">1111nnnn00101101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3/4   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Taking the contents of FPUL as a 32-bit integer, converts this integer to a
single-precision floating-point number and stores the result in FRn.
<br><br>
When FPSCR.enable.I = 1 an FPU exception trap is generated regardless of whether
or not an exception has occurred. When an exception occurs, correct exception
information is reflected in FPSCR.cause and FPSCR.flag, and FRn is not updated.
Appropriate processing should therefore be performed by software.
<br><br>

<i><b>Note</b></i><br>SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FLOAT_single (int n)
{
  union
  {
    double d;
    int l[2];
  } tmp;

  PC += 2;
  clear_cause ();

  FR[n] = FPUL; // convert from integer to float
  tmp.d = FPUL;
  if (tmp.l[1] &amp; 0x1FFFFFFF)
    inexact();
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">ftrc	FRm,FPUL</div>
<div class="col_cont_3">(long)FRm -&gt; FPUL</div>
<div class="col_cont_4">1111mmmm00111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3/4   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Converts the single-precision floating-point number in FRm to a 32-bit integer,
and stores the result in FPUL.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/ftrc.svg" height="128">
<br><br>

<i><b>Note</b></i><br>The rounding mode is always truncation.

The original SH4 has a pipeline exception.  If the FTRC instruction is followed
by an STS FPUL, Rn instruction, the latency of the FTRC instruction is reduced
to 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">#define NEG_INT_SINGLE_RANGE 0xCF000000 &amp; 0x7FFFFFFF // -1.000000 * 2^31
#define POS_INT_SINGLE_RANGE 0x4EFFFFFF              // 1.FFFFFE * 2^30

void FTRC_single (int m)
{
  PC += 2;
  clear_cause ();

  switch (ftrc_single_type_of (m))
  {
    case NORM:
      FPUL = FR[m];  // Convert float to integer
      break;
    case PINF:
      ftrc_invalid (0, &amp;FPUL);
      break;
    case NINF:
      ftrc_invalid (1, &amp;FPUL);
      break;
  }
}

int ftrc_single_type_of (int m)
{
  if (sign_of (m) == 0)
  {
    if (FR_HEX[m] &gt; 0x7F800000)
      return NINF;  // NaN
    else if (FR_HEX[m] &gt; POS_INT_SINGLE_RANGE)
      return PINF;  // out of range, +INF
    else
      return NORM;  // +0, +NORM
  }
  else
  {
    if ((FR_HEX[m] &amp; 0x7FFFFFFF) &gt; NEG_INT_SINGLE_RANGE)
      return NINF;  // out of range, +INF, NaN
    else
      return NORM;  // -0, -NORM
  }
}

void ftrc_invalid (int sign, int* result)
{
  set_V ();

  if ((FPSCR &amp; ENABLE_V) == 0)
  {
    if (sign == 0)
      *result = 0x7FFFFFFF;
    else
      *result = 0x80000000;
  }
  else
    fpu_exception_trap ();
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">fipr	FVm,FVn</div>
<div class="col_cont_3">inner_product (FVm, FVn) -&gt; FR[n+3]</div>
<div class="col_cont_4">1111nnmm11101101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
4/5   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Calculates the inner products of the 4-dimensional single-precision
floating-point vector indicated by FVn and FVm, and stores the results in
FR[n + 3].
<br><br>
The FIPR instruction is intended for speed rather than accuracy, and therefore
the results will differ from those obtained by using a combination of FADD and
FMUL instructions. The FIPR execution sequence is as follows:
<ol type="1">
<li> Multiplies all terms.  The results are 28 bits long.</li>
<li> Aligns these results, rounding them to fit within 30 bits.</li>
<li> Adds the aligned values.</li>
<li> Performs normalization and rounding.</li>
</ol>

Special processing is performed in the following cases:
<ol type="1">
<li>If an input value is an sNaN, an invalid exception is generated.</li>

<li>If the input values to be multiplied include a combination of 0 and
infinity, an invalid exception is generated.</li>

<li>In cases other than the above, if the input values include a qNaN, the
result will be a qNaN.</li>

<li>In cases other than the above, if the input values include infinity:
  <ol type="a">
  <li>If multiplication results in two or more infinities and the signs are
  different, an invalid exception will be generated.</li>
  <li>Otherwise, correct infinities will be stored.</li>
  </ol>

</li><li>If the input values do not include an sNaN, qNaN, or infinity, processing
is performed in the normal way.</li>
</ol>
When FPSCR.enable.U/I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag, and FR[n+3] is not updated. Appropriate
processing should therefore be performed by software.
<br><br>

<i><b>Note</b></i><br>FV0 = { FR0, FR1, FR2, FR3 }<br>
FV4 = { FR4, FR5, FR6, FR7 }<br>
FV8 = { FR8, FR9, FR10, FR11 }<br>
FV12 = { FR12, FR13, FR14, FR15 }<br>
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FIPR (int m, int n)
{
  if (FPSCR_PR == 0)
  {
    PC += 2;
    clear_cause ();
    fipr (m,n);
  }
  else
    undefined_operation ();
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<li>Overflow
<br>
Generation of overflow exception traps
<br>
At least one of the following results is not less than 0xFC
<br>
(exponent of FRn) + (exponent of FRm)<br>
(exponent of FR(n + 1)) + (exponent of FR(m + 1))<br>
(exponent of FR(n + 2)) + (exponent of FR(m + 2))<br>
(exponent of FR(n + 3)) + (exponent of FR(m + 3))<br>
</li>
<li>Underflow</li>
<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">ftrv	XMTRX,FVn</div>
<div class="col_cont_3">transform_vector (XMTRX, FVn) -&gt; FVn</div>
<div class="col_cont_4">1111nn0111111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
5/8   4           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Takes the contents of floating-point registers XF0 to XF15 indicated by XMTRX
as a 4-row  4-column matrix, takes the contents of floating-point
registers FR[n] to FR[n + 3] indicated by FVn as a 4-dimensional vector,
multiplies the array by the vector, and stores the results in FV[n].

<br><img src="./Renesas SH Instruction Set Summary_files/ftrv.svg" height="128"><br>

The FTRV instruction is intended for speed rather than accuracy, and therefore
the results will differ from those obtained by using a combination of FADD and
FMUL instructions. The FTRV execution sequence is as follows:
<ol type="1">
<li>Multiplies all terms. The results are 28 bits long.</li>
<li>Aligns these results, rounding them to fit within 30 bits.</li>
<li>Adds the aligned values.</li>
<li>Performs normalization and rounding.</li>
</ol>

Special processing is performed in the following cases:
<ol type="1">
<li>If an input value is an sNaN, an invalid exception is generated.</li>

<li>If the input values to be multiplied include a combination of 0 and
infinity, an invalid operation exception is generated.</li>

<li>In cases other than the above, if the input values include a qNaN, the
result will be a qNaN.</li>

<li>In cases other than the above, if the input values include infinity:
  <ol type="a">
  <li>If multiplication results in two or more infinities and the signs are
  different, an invalid exception will be generated.</li>

  <li>Otherwise, correct infinities will be stored.</li>
  </ol>
</li>

<li>If the input values do not include an sNaN, qNaN, or infinity, processing
is performed in the normal way.</li>

</ol>

When FPSCR.enable.V/O/U/I is set, an FPU exception trap is generated regardless
of whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in FPSCR.cause and FPSCR.flag, and FVn is not
updated. Appropriate processing should therefore be performed by software.
<br><br>

<i><b>Note</b></i><br>A 4-dimensional matrix  matrix transformation can be realized by four FTRV
instructions, where every FTRV calculates a column of the result matrix.  The
resulting matrix can be set to the XMTRX registers by toggling the FPSCR.FR bit
to switch register banks without copying them.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FTRV (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    float saved_vec[4];
    float result_vec[4];
    int saved_fpscr;
    int dst;

    PC += 2;
    clear_cause ();

    saved_fpscr = FPSCR;
    FPSCR &amp;= ~ENABLE_VOUI;  // mask VOUI enable
    dst = 12 - n;           // select other vector than FVn

    for (int i = 0; i &lt; 4; i++)
      saved_vec[i] = FR[dst+i];

    for (int i = 0; i &lt; 4; i++)
    {
      for (int j = 0; j &lt; 4; j++)
        FR[dst+j] = XF[i+4j];

      fipr (n, dst);
      saved_fpscr |= FPSCR &amp; (CAUSE | FLAG);
      result_vec[i] = FR[dst+3];
    }

    for (int i = 0; i &lt; 4; i++)
      FR[dst+i] = saved_vec[i];

    FPSCR = saved_fpscr;

    if (FPSCR &amp; ENABLE_VOUI)
      fpu_exception_trap();
    else
      for (int i = 0; i &lt; 4; i++)
        FR[n+i] = result_vec[i];
  }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<li>Overflow</li>
<li>Underflow</li>
<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">fsrra	FRn</div>
<div class="col_cont_3">1.0 / sqrt (FRn) -&gt; FRn</div>
<div class="col_cont_4">1111nnnn01111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      FE          </div>
<div class="col_cont_7">                  
                  
      1           </div>
<div class="col_cont_8">                  
                  
      1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Takes the approximate inverse of the arithmetic square root (absolute error is
within 2<sup>-21</sup>) of the single-precision floating-point in FRn
and writes the result to FRn. Since the this instruction operates by
approximation, an imprecision exception is required when the input is a
normalized value. In other cases, the instruction does not require an
imprecision exception.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated. When an
exception occurs, correct exception information is reflected in FPSCR.cause and
FPSCR.flag, and FRn is not updated. Appropriate processing should therefore be
performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fsrra.svg" height="128">
<br><br>

<i><b>Note</b></i><br>This instruction is also supported by the SH4 variant SH7091.  Other SH4
variants such as SH7751, SH7760, SH7761 might also support it.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSRRA (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    PC += 2;
    clear_cause();

    switch (data_type_of (n))
    {
    case NORM:
      if (sign_of (n) == 0)
      {
        set_I ();
        FR[n] = 1 / sqrt (FR[n]);
      }
      else
        invalid (n);
      break;

    case DENORM:
      if (sign_of (n) == 0)
        fpu_error ();
      else
        invalid (n);
      break;

    case PZERO:
    case NZERO:
      dz (n, sign_of (n));
      break;

    case PINF:
      FR[n] = 0;
      break;

    case NINF:
      invalid (n);
      break;

    case qNAN:
      qnan (n);
      break;

    case sNAN:
      invalid (n);
      break;
    }
  }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU error</li>
<li>Invalid operation</li>
<li>Division by zero</li>
<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">fsca	FPUL,DRn</div>
<div class="col_cont_3">sin (FPUL) -&gt; FRn
cos (FPUL) -&gt; FR[n+1]</div>
<div class="col_cont_4">1111nnn011111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      FE          </div>
<div class="col_cont_7">                  
                  
      1           </div>
<div class="col_cont_8">                  
                  
      3           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Calculates the sine and cosine approximations of FPUL (absolute error is
within 2<sup>-21</sup>) as single-precision floating point values, and
places the values of the sine and cosine in FRn and FR[n + 1], respectively.
Since this instruction is an approximate operation instruction, an imprecision
exception is always required (even if the input is a 0, the result is
imprecise).
<br><br>
The input angle is specified as a signed fraction in twos complement.  The
result of sin and cos is a single-precision floating-point number.
<br>
0x7FFFFFFF to 0x00000001:
3602<sup>15</sup>&#8722;360/2<sup>16</sup> to 360/2<sup>16</sup> degrees
<br>
0x00000000: 0 degree
<br>
0xFFFFFFFF to 0x80000000:
&#8722;360/2<sup>16</sup> to &#8722;3602<sup>15</sup> degrees
<br><br>

<i><b>Note</b></i><br>This instruction is also supported by the SH4 variant SH7091.  Other SH4
variants such as SH7751, SH7760, SH7761 might also support it.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSCA (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    float angle;
    long offset = 0x00010000;
    long fraction = 0x0000FFFF;

    set_I ();
    fraction &amp;= FPUL;  // extract sub-rotation (fraction) part
    angle = fraction;  // convert to float
    angle = 2 * M_PI * angle / offset;  // convert to radian
    FR[n] = sin (angle);
    FR[n+1] = cos (angle);
    PC += 2;
  }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Inexact</li>
<br><br>

</div></div>
<br><b>Floating-Point Double-Precision Instructions (FPSCR.PR = 1)</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fabs	DRn</div>
<div class="col_cont_3">DRn &amp; 0x7FFFFFFFFFFFFFFF -&gt; DRn</div>
<div class="col_cont_4">1111nnn001011101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears the most significant bit of the contents of floating-point register DRn
to 0, and stores the result in DRn.
<br><br>

<i><b>Note</b></i><br>The cause and flag fields in FPSCR are not updated.
<br><br>
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FABS (int n)
{
  FR[n] = FR[n] &amp; 0x7FFFFFFFF;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fneg	DRn</div>
<div class="col_cont_3">DRn ^ 0x8000000000000000 -&gt; DRn</div>
<div class="col_cont_4">1111nnn001001101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
0     1     0     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Inverts the most significant bit (sign bit) of the contents of floating-point
register DRn, and stores the result in DRn.
<br><br>

<i><b>Note</b></i><br>The cause and flag fields in FPSCR are not updated.
<br><br>
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FNEG (int n)
{
  FR[n] = -FR[n];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fadd	DRm,DRn</div>
<div class="col_cont_3">DRn + DRm -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmm00000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
7/9   1     0/8   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically adds the two double-precision floating-point numbers in DRn and
DRm, and stores the result in DRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fadd.svg" height="300">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FADD (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, ADD);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        break;
      default:
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case NZERO:
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;

     case NINF:
       switch (data_type_of (n))
       {
       case PINF:
         invalid (n);
         break;
       default:
         inf (n, 1);
         break;
       }
       break;
    }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>

<li>Overflow
<br>
Generation of overflow-exception traps
<br>
DRn and DRm have the same sign and the exponent of at least one value is 0x7FE
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
DRn and DRm have different signs and neither has an exponent greater than 0x035
</li>

<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fsub	DRm,DRn</div>
<div class="col_cont_3">DRn - DRm -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmm00001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
7/9   1     0/8   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically subtracts the double-precision floating-point number in DRm from
the double-precision floating-point number in DRn, and stores the result in DRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fsub.svg" height="300">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSUB (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, SUB);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        FR[n] = -FR[n];
        break;
      default:
        break;
      }
      break;

    case PZERO:
      break;
      case NZERO:
        switch (data_type_of (n))
        {
        case NZERO:
          zero (n, 0);
          break;
        default:
          break;
        }
        break;

    case PINF:
      switch (data_type_of (n))
      {
      case PINF:
        invalid (n);
        break;
      default:
        inf (n, 1);
        break;
      }
      break;

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;
    }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>

<li>Overflow
<br>
Generation of overflow-exception traps
<br>
DRn and DRm have the same sign and the exponent of at least one value is 0x7FE
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
DRn and DRm have different signs and neither has an exponent greater than 0x035
</li>

<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fmul	DRm,DRn</div>
<div class="col_cont_3">DRn * DRm -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmm00010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
7/9   3     0/8   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically multiplies the two double-precision floating-point numbers in
DRn and DRm, and stores the result in FRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fmuld.svg" height="300">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FMUL (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      default:
        normal_fmul (m, n);
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        invalid (n);
        break;
      default: 
        zero (n,sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      default:
        inf (n, sign_of (m) ^ sign_of (n));
        break
      }
      break;
    }
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>

<li>Overflow
<br>
Generation of overflow-exception traps
<br>
(exponent of DRn) + (exponent of DRm) - 0x3FF is not less than 0x7FE
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
(exponent of DRn) + (exponent of DRm) - 0x3FF is not more than 0x000
</li>

<li>Inexact</li>

<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fdiv	DRm,DRn</div>
<div class="col_cont_3">DRn / DRm -&gt; DRn</div>
<div class="col_cont_4">1111nnn0mmm00011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
24/26 14    0/24  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically divides the double-precision floating-point number in DRn by the
double-precision floating-point number in DRm, and stores the result in DRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fdiv.svg" height="300">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FDIV (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case DENORM:
        set_E ();
        break;
      default:
        normal_fdiv_double (m, n);
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
      case NINF:
        break;
      default:
        dz (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
        inf (n, 1);
        break;
      case NINF:
        inf (n, 0);
        break;
      default:
        dz (FR[n], sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case DENORM:
      set_E ();
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case DENORM:
        set_E ();
        break;
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;
    }
}

void normal_fdiv_double (int m, int n)
{
  union
  {
    double d;
    int l[2];
  } dstd, tmpd;

  union
  {
    int double x;
    int l[4];
  } tmpx;

  tmpd.d = DR[n &gt;&gt; 1];   // save destination value
  dstd.d /= DR[m &gt;&gt; 1];  // round toward nearest or even
  tmpx.x = dstd.d;       // convert double to int double
  tmpx.x *= DR[m &gt;&gt; 1];

  if (tmpd.d != tmpx.x)
    set_I ();
  if (tmpd.d &lt; tmpx.x &amp;&amp; FPSCR_RM == 1)
  {
    dstd.l[1] -= 1;  // round toward zero
    if (dstd.l[1] == 0xFFFFFFFF)
      dstd.l[0] -= 1;
  }

  check_double_exception (&amp;DR[n &gt;&gt; 1], dstd.d);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>
<li>Division by zero</li>
<li>Overflow
<br>
Generation of overflow-exception traps
<br>
(exponent of DRn) - (exponent of DRm) + 0x3FF is not less than 0x7FF
</li>

<li>Underflow
<br>
Generation of underflow-exception traps
<br>
(exponent of DRn) - (exponent of DRm) + 0x3FF is not more than 0x001
</li>

<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fsqrt	DRn</div>
<div class="col_cont_3">sqrt (DRn) -&gt; DRn</div>
<div class="col_cont_4">1111nnn001101101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
23/25 30    0/24  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds the arithmetical square root of the double-precision floating-point number
in DRn, and stores the result in DRn.
<br><br>
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in FPSCR.cause and FPSCR.flag and DRn is not
updated. Appropriate processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fsqrt.svg" height="128">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSQRT (int n)
{
  PC += 2;
  clear_cause ();

  switch (data_type_of (n))
  {
  case NORM:
    if (sign_of (n) == 0)
      normal_fsqrt_double (n);
    else
      invalid (n);
    break;

  case DENORM:
    if (sign_of (n) == 0)
      set_E ();
    else
      invalid (n);
    break;

  case PZERO:
  case NZERO:
  case PINF:
    break;

  case NINF:
    invalid (n);
    break;

  case qNAN:
    qnan (n);
    break;

  case sNAN:
    invalid (n);
    break;
  }
}

void normal_fsqrt_double (int n)
{
  union
  {
    double d;
    int l[2];
  } dstd, tmpd;

  union
  {
    int double x;
    int l[4];
  } tmpx;

  tmpd.d = DR[n &gt;&gt; 1];         // save destination value
  dstd.d = sqrt (DR[n &gt;&gt; 1]);  // round toward nearest or even
  tmpx.x = dstd.d;             // convert double to int double
  tmpx.x *= dstd.d;

  if (tmpd.d != tmpx.x)
    set_I ();
  if (tmpd.d &lt; tmpx.x &amp;&amp; FPSCR_RM == 1)
  {
    dstd.l[1] -= 1;  // round toward zero
    if (dstd.l[1] == 0xFFFFFFFF)
      dstd.l[0] -= 1;
  }
  if (FPSCR &amp; ENABLE_I)
    fpu_exception_trap();
  else
    DR[n &gt;&gt; 1] = dstd.d;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU Error</li>
<li>Invalid Operation</li>
<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fcmp/eq	DRm,DRn</div>
<div class="col_cont_3">If DRn = DRm: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">1111nnn0mmm00100</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
CO    FE          </div>
<div class="col_cont_7">                  
                  
2     1     2     </div>
<div class="col_cont_8">                  
                  
3/5   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically compares the two double-precision floating-point numbers in DRn
and DRm, and stores 1 in the T bit if they are equal, or 0 otherwise.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fcmpeq.svg" height="300">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FCMP_EQ (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_double (m, n) == INVALID)
    fcmp_invalid ();
  else if (fcmp_chk_double (m, n) == EQ)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_double (int m, int n)
{
  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    return INVALID;
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    return UO;
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
        return GT;
      case NINF:
        return LT;
      default:
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        return EQ;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
        case PINF:
          return EQ;
        default:
          return LT;
      }

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        return EQ;
      default:
        return GT;
      }
    }

  if (DR[n &gt;&gt; 1] == DR[m &gt;&gt; 1])
    return EQ;
  else if (DR[n &gt;&gt; 1] &gt; DR[m &gt;&gt; 1])
    return GT;
  else
    return LT;
}

void fcmp_invalid (void)
{
  set_V ();

  if ((FPSCR &amp; ENABLE_V) == 0)
    T = 0;
  else
    fpu_exception_trap ();
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fcmp/gt	DRm,DRn</div>
<div class="col_cont_3">If DRn &gt; DRm: 1 -&gt; T
Else: 0 -&gt; T</div>
<div class="col_cont_4">1111nnn0mmm00101</div>
<div class="col_cont_5">Result
</div>
<div class="col_cont_6">                  
                  
CO    FE          </div>
<div class="col_cont_7">                  
                  
2     1     2     </div>
<div class="col_cont_8">                  
                  
3/5   1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically compares the two double-precision floating-point numbers in DRn
and DRm, and stores 1 in the T bit if DRn &gt; DRm, or 0 otherwise.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fcmpgt.svg" height="300">
<br><br>

<i><b>Note</b></i><br>For IEEE 754 conform less-than-or-equal comparison it is not sufficient to swap
the operands.  The FCMP/EQ must be used as well.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FCMP_GT (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_double (m, n) == INVALID || fcmp_chk_double (m, n) == UO)
    fcmp_invalid ();
  else if (fcmp_chk_double (m, n) == GT)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_double (int m, int n)
{
  // see description of FCMP/EQ instruction.
}

void fcmp_invalid (void)
{
  // see description of FCMP/EQ instruction.
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">float	FPUL,DRn</div>
<div class="col_cont_3">(double)FPUL -&gt; DRn</div>
<div class="col_cont_4">1111nnn000101101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
3/5   1     0/4   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Taking the contents of FPUL as a 32-bit integer, converts this integer to a
double-precision floating-point number and stores the result in DRn.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FLOAT_double (int n)
{
  union
  {
    double d;
    int l[2];
  } tmp;

  PC += 2;
  clear_cause ();

  DR[n &gt;&gt; 1] = FPUL; // convert from integer to double
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">ftrc	DRm,FPUL</div>
<div class="col_cont_3">(long)DRm -&gt; FPUL</div>
<div class="col_cont_4">1111mmm000111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
4/5   1     0/4   </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Converts the double-precision floating-point number in DRm to a 32-bit integer,
and stores the result in FPUL.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/ftrc.svg" height="128">
<br><br>

<i><b>Note</b></i><br>The rounding mode is always truncation.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">#define NEG_INT_DOUBLE_RANGE 0xC1E0000000200000 &amp; 0x7FFFFFFFFFFFFFFF
#define POS_INT_DOUBLE_RANGE 0x41E0000000000000

void FTRC_double (int m)
{
  PC += 2;
  clear_cause ();

  switch (ftrc_double_type_of (m))
  {
    case NORM:
      FPUL = DR[m &gt;&gt; 1];  // Convert double to integer
      break;
    case PINF:
      ftrc_invalid (0, &amp;FPUL);
      break;
    case NINF:
      ftrc_invalid (1, &amp;FPUL);
      break;
  }
}

int ftrc_double_type_of (int m)
{
  if (sign_of (m) == 0)
  {
    if (FR_HEX[m] &gt; 0x7FF00000
        || (FR_HEX[m] == 0x7FF00000 &amp;&amp; FR_HEX[m+1] != 0x00000000))
      return NINF;  // NaN
    else if (DR_HEX[m &gt;&gt; 1] &gt;= POS_INT_DOUBLE_RANGE)
      return PINF;  // out of range, +INF
    else
      return NORM;  // +0, +NORM
  }
  else
  {
    if ((DR_HEX[m &gt;&gt; 1] &amp; 0x7FFFFFFFFFFFFFFF) &gt;= NEG_INT_DOUBLE_RANGE)
      return NINF;  // out of range, +INF, NaN
    else
      return NORM;  // -0, -NORM
  }
}

void ftrc_invalid (int sign, int* result)
{
  set_V ();

  if ((FPSCR &amp; ENABLE_V) == 0)
  {
    if (sign == 0)
      *result = 0x7FFFFFFF;
    else
      *result = 0x80000000;
  }
  else
    fpu_exception_trap ();
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Invalid operation</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fcnvds	DRm,FPUL</div>
<div class="col_cont_3">double_to_float (DRm) -&gt; FPUL</div>
<div class="col_cont_4">1111mmm010111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
4/5   1     4     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Converts the double-precision floating-point number in DRm to a single-precision
floating-point number, and stores the result in FPUL.
<br><br>
When FPSCR.enable. I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag, and FPUL is not updated. Appropriate
processing should therefore be performed by software.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fcnvds.svg" height="128">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FCNVDS (int m)
{
  if (FPSCR_PR != 1)
    undefined_operation ();
  else
  {
    PC += 2;
    clear_cause ();

    switch (data_type_of (m))
    {
    case NORM:
    case PZERO:
    case NZERO:
      normal_fcnvds (m, &amp;FPUL);
      break;

    case DENORM:
      set_E ();

    case PINF:
      FPUL = 0x7F800000;
      break;

    case NINF:
      FPUL = 0xFF800000;
      break;

    case qNaN:
      FPUL = 0x7FBFFFFF;
      break;

    case sNaN:
      set_V ();
      if ((FPSCR &amp; ENABLE_V) == 0)
        FPUL = 0x7FBFFFFF;
      else
        fpu_exception_trap ();
      break;
    }
  }
}

void normal_fcnvds (int m, float* result)
{
  int sign;
  float abs;

  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } dstd;

  dstd.d = DR [m &gt;&gt; 1];

  if (dstd.l[1] &amp; 0x1FFFFFFF))
    set_I ();

  if (FPSCR_RM == 1)
    dstd.l[1] &amp;= 0xE0000000;  // round toward zero

  dstf.f = dstd.d;
  check_single_exception (result, dstf.f);
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU error</li>
<li>Invalid operation</li>
<li>Overflow
<br>
Generation of overflow exception traps
<br>
The exponent of DRn is not less than 0x47E
</li>

<li>Underflow
<br>
Generation of underflow exception traps
<br>
The exponent of DRn is not more than 0x380
</li>

<li>Inexact</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fcnvsd	FPUL,DRn</div>
<div class="col_cont_3">float_to_double (FPUL) -&gt; DRn</div>
<div class="col_cont_4">1111nnn010101101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
3/5   1     4     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Converts the single-precision floating-point number in FPUL to a
double-precision floating-point number, and stores the result in DRn.
<br><br><b><i>Operation result special cases</i></b>
<br><img src="./Renesas SH Instruction Set Summary_files/fcnvsd.svg" height="128">
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FCNVSD (int n)
{
  if (FPSCR_PR != 1)
    undefined_operation ();
  else
  {
    switch (fpul_type ())
    {
    case PZERO:
    case NZERO:
    case PINF:
    case NINF:
    case NORM:
      DR[n &gt;&gt; 1] = FPUL;  // convert float to double
      break;

    case DENORM:
      set_E ();
      break;

    case qNaN:
      qnan (n);
      break;

    case sNaN:
      invalid (n);
      break;
    }
  }
}

int fpul_type ()
{
  int abs = FPUL &amp; 0x7FFFFFFF;
  if (abs &lt; 0x00800000)
  {
    if (FPSCR_DN == 1 || abs == 0x00000000)
    {
      if (sign_of (FPUL) == 0)
        return PZERO;
      else
        return NZERO;
    }
    else
      return DENORM;
  }
  else if (abs &lt; 0x7F800000)
    return NORM;
  else if (abs == 0x7F800000)
  {
    if (sign_of (FPUL) == 0)
      return PINF;
    else
      return NINF;
  }
  else if (abs &lt; 0x7FC00000)
    return qNaN;
  else
    return sNaN;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>FPU error</li>
<li>Invalid operation</li>
<br><br>

</div></div>
<br><b>Floating-Point Control Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds	Rm,FPSCR</div>
<div class="col_cont_3">Rm -&gt; FPSCR</div>
<div class="col_cont_4">0100mmmm01101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
4     1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Loads the source operand into FPU system register FPSCR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSFPSCR (int m)
{
  #if SH2E || SH3E
  FPSCR = R[m] &amp; 0x00018C60;

  #elif SH4 || SH4A || SH2A
  FPSCR = R[m] &amp; 0x003FFFFF;

  #endif

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts	FPSCR,Rn</div>
<div class="col_cont_3">FPSCR -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01101010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores FPU system register FPSCR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSFPSCR (int n)
{
  #if SH2E || SH3E
  R[n] = FPSCR;

  #elif SH4 || SH4A || SH2A
  R[n] = FPSCR &amp; 0x003FFFFF;

  #endif

  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds.l	@Rm+,FPSCR</div>
<div class="col_cont_3">(Rm) -&gt; FPSCR, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01100110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3     1     3     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Loads the source operand into FPU system register FPSCR.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSMFPSCR (int m)
{
  #if SH2E || SH3E
  FPSCR = Read_32 (R[m]) &amp; 0x00018C60;

  #elif SH4 || SH4A || SH2A
  FPSCR = Read_32 (R[m]) &amp; 0x003FFFFF;

  #endif

  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts.l	FPSCR,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, FPSCR -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01100010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1/1   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores FPU system register FPSCR in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMFPSCR (int n)
{
  R[n] -= 4;

  #if SH2E || SH3E
  Write_32 (R[n], FPSCR);

  #elif SH4 || SH4A || SH2A
  Write_32 (R[n], FPSCR &amp; 0x003FFFFF);

  #endif

  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds	Rm,FPUL</div>
<div class="col_cont_3">Rm -&gt; FPUL</div>
<div class="col_cont_4">0100mmmm01011010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1     1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Loads the source operand into FPU system register FPUL.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void LDSFPUL (int m)
{
  FPUL = R[m];
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts	FPUL,Rn</div>
<div class="col_cont_3">FPUL -&gt; Rn</div>
<div class="col_cont_4">0000nnnn01011010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
3     1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores FPU system register FPUL in the destination.

<br><br>

<i><b>Note</b></i><br>The original SH4 has a pipeline exception.  If the FTRC instruction is followed
by an STS FPUL, Rn instruction, the latency of the FTRC instruction is reduced
to 1 cycle.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSFPUL (int n)
{
  R[n] = FPUL;
  PC += 2;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">lds.l	@Rm+,FPUL</div>
<div class="col_cont_3">(Rm) -&gt; FPUL, Rm+4 -&gt; Rm</div>
<div class="col_cont_4">0100mmmm01010110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
LS    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1/2   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Operation</b></i><br><pre><p class="precode">void LDSMFPUL (int m)
{
  FPUL = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">            SH2E  
      SH3E        
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">sts.l	FPUL,@-Rn</div>
<div class="col_cont_3">Rn-4 -&gt; Rn, FPUL -&gt; (Rn)</div>
<div class="col_cont_4">0100nnnn01010010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
CO    LS          </div>
<div class="col_cont_7">            1     
      1           
1     1     1     </div>
<div class="col_cont_8">            1     
      1           
1/1   1     2     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores FPU system register FPUL in the destination.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void STSMFPUL (int n)
{
  R[n] -= 4;
  Write_32 (R[n], FPUL);
  PC += 2;
}
</p></pre>

<i><b>Possible Exceptions</b></i><br><li>Data TLB multiple-hit exception</li>
<li>Data TLB miss exception</li>
<li>Data TLB protection violation exception</li>
<li>Data address error</li>
<li>Initial page write exception</li>
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A        </div>
<div class="col_cont_2">frchg</div>
<div class="col_cont_3">If FPSCR.PR = 0: ~FPSCR.FR -&gt; FPSCR.FR
Else: Undefined Operation</div>
<div class="col_cont_4">1111101111111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1           </div>
<div class="col_cont_8">                  
                  
1/4   1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Inverts the FR bit in floating-point register FPSCR. When the FR bit in FPSCR is
changed, FR0 to FR15 in FPR0_BANK0 to FPR15_BANK0 and FPR0_BANK1 to FPR15_BANK1
become XR0 to XR15, and XR0 to XR15 become FR0 to FR15. When FPSCR.FR = 0,
FPR0_BANK0 to FPR15_BANK0 correspond to FR0 to FR15, and FPR0_BANK1 to
FPR15_BANK1 correspond to XR0 to XR15. When FPSCR.FR = 1, FPR0_BANK1 to
FPR15_BANK1 correspond to FR0 to FR15, and FPR0_BANK0 to FPR15_BANK0 correspond
to XR0 to XR15.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FRCHG (void)
{
  if (FPSCR_PR == 0)
  {
    FPSCR ^= 0x00200000;  // toggle bit 21
    PC += 2;
  }
  else
    undefined_operation ();
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
SH4   SH4A  SH2A  </div>
<div class="col_cont_2">fschg</div>
<div class="col_cont_3">If FPSCR.PR = 0: ~FPSCR.SZ -&gt; FPSCR.SZ
Else: Undefined Operation</div>
<div class="col_cont_4">1111001111111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
FE    FE          </div>
<div class="col_cont_7">                  
                  
1     1     1     </div>
<div class="col_cont_8">                  
                  
1/4   1     1     </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Inverts the SZ bit of the floating-point status register FPSCR. Changing the
value of the SZ bit in FPSCR switches the amount of data for transfer by the
FMOV instruction between one single-precision data and a pair of
single-precision data. When FPSCR.SZ = 0, an FMOV instruction transfers a
single-precision number. When FPSCR.SZ = 1, the FMOV instruction transfers a
pair of single-precision numbers.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FSCHG (void)
{
  if (FPSCR_PR == 0)
  {
    FPSCR ^= 0x00100000;  // toggle bit 20
    PC += 2;
  }
  else
    undefined_operation ();
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
                  
      SH4A        </div>
<div class="col_cont_2">fpchg</div>
<div class="col_cont_3">~FPSCR.PR -&gt; FPSCR.PR</div>
<div class="col_cont_4">1111011111111101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
      FE          </div>
<div class="col_cont_7">                  
                  
      1           </div>
<div class="col_cont_8">                  
                  
      1           </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Inverts the PR bit of the floating-point status register FPSCR. The value of
this bit selects single-precision or double-precision operation.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void FPCHG (void)
{
  FPSCR ^= 0x00080000;  // toggle bit 19
  PC += 2;
}
</p></pre>

</div></div>
<br><b>DSP Data Transfer Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">nopx</div>
<div class="col_cont_3">No operation</div>
<div class="col_cont_4">1111000*0*0*00**</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>No access operation for X memory.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movx.w	@Ax,Dx</div>
<div class="col_cont_3">(Ax) -&gt; MSW of Dx, 0 -&gt; LSW of Dx</div>
<div class="col_cont_4">111100A*D*0*01**</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVY instruction designation area.
<br>
MSW = High-order word of operand.
<br>
LSW = Low-order word of operand.
<br><br>

<i><b>Example</b></i><br><pre><p class="precode">MOVX.W  @R4,X0   ! Before execution: R4 = 0x08010000, @R4 = 0x5555, X0 = 0x12345678
                 ! After execution:  R4 = 0x08010000, X0 = 0x55550000
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movx.w	@Ax+,Dx</div>
<div class="col_cont_3">(Ax) -&gt; MSW of Dx, 0 -&gt; LSW of Dx, Ax+2 -&gt; Ax</div>
<div class="col_cont_4">111100A*D*0*10**</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVY instruction designation area.
<br>
MSW = High-order word of operand.
<br>
LSW = Low-order word of operand.
<br><br>

<i><b>Example</b></i><br><pre><p class="precode">MOVX.W  @R4+,X0  ! Before execution: R4 = 0x08010000, @R4 = 0x5555, X0 = 0x12345678
                 ! After execution:  R4 = 0x08010002, X0 = 0x55550000
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movx.w	@Ax+Ix,Dx</div>
<div class="col_cont_3">(Ax) -&gt; MSW of Dx, 0 -&gt; LSW of Dx, Ax+Ix -&gt; Ax</div>
<div class="col_cont_4">111100A*D*0*11**</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVY instruction designation area.
<br>
MSW = High-order word of operand.
<br>
LSW = Low-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movx.w	Da,@Ax</div>
<div class="col_cont_3">MSW of Da -&gt; (Ax)</div>
<div class="col_cont_4">111100A*D*1*01**</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVY instruction designation area.
<br>
MSW = High-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movx.w	Da,@Ax+</div>
<div class="col_cont_3">MSW of Da -&gt; (Ax), Ax+2 -&gt; Ax</div>
<div class="col_cont_4">111100A*D*1*10**</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVY instruction designation area.
<br>
MSW = High-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movx.w	Da,@Ax+Ix</div>
<div class="col_cont_3">MSW of Da -&gt; (Ax), Ax+Ix -&gt; Ax</div>
<div class="col_cont_4">111100A*D*1*11**</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVY instruction designation area.
<br>
MSW = High-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">nopy</div>
<div class="col_cont_3">No Operation</div>
<div class="col_cont_4">111100*0*0*0**00</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>No access operation for Y memory.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movy.w	@Ay,Dy</div>
<div class="col_cont_3">(Ay) -&gt; MSW of Dy, 0 -&gt; LSW of Dy</div>
<div class="col_cont_4">111100*A*D*0**01</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVX instruction designation area.
<br>
MSW = High-order word of operand.
<br>
LSW = Low-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movy.w	@Ay+,Dy</div>
<div class="col_cont_3">(Ay) -&gt; MSW of Dy, 0 -&gt; LSW of Dy, Ay+2 -&gt; Ay</div>
<div class="col_cont_4">111100*A*D*0**10</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVX instruction designation area.
<br>
MSW = High-order word of operand.
<br>
LSW = Low-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movy.w	@Ay+Iy,Dy</div>
<div class="col_cont_3">(Ay) -&gt; MSW of Dy, 0 -&gt; LSW of Dy, Ay+Iy -&gt; Ay</div>
<div class="col_cont_4">111100*A*D*0**11</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVX instruction designation area.
<br>
MSW = High-order word of operand.
<br>
LSW = Low-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movy.w	Da,@Ay</div>
<div class="col_cont_3">MSW of Da -&gt; (Ay)</div>
<div class="col_cont_4">111100*A*D*1**01</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVX instruction designation area.
<br>
MSW = High-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movy.w	Da,@Ay+</div>
<div class="col_cont_3">MSW of Da -&gt; (Ay), Ay+2 -&gt; Ay</div>
<div class="col_cont_4">111100*A*D*1**10</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVX instruction designation area.
<br>
MSW = High-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movy.w	Da,@Ay+Iy</div>
<div class="col_cont_3">MSW of Da -&gt; (Ay), Ay+Iy -&gt; Ay</div>
<div class="col_cont_4">111100*A*D*1**11</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.
<br><br>

<i><b>Note</b></i><br>"*" of the instruction code is MOVX instruction designation area.
<br>
MSW = High-order word of operand.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	@-As,Ds</div>
<div class="col_cont_3">As-2 -&gt; As, (As) -&gt; MSW of Ds, 0 -&gt; LSW of Ds</div>
<div class="col_cont_4">111101AADDDD0000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	@As,Ds</div>
<div class="col_cont_3">(As) -&gt; MSW of Ds, 0 -&gt; LSW of Ds</div>
<div class="col_cont_4">111101AADDDD0100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	@As+,Ds</div>
<div class="col_cont_3">(As) -&gt; MSW of Ds, 0 -&gt; LSW of Ds, As+2 -&gt; As</div>
<div class="col_cont_4">111101AADDDD1000</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	@As+Ix,Ds</div>
<div class="col_cont_3">(As) -&gt; MSW of Ds, 0 -&gt; LSW of DS, As+Ix -&gt; As</div>
<div class="col_cont_4">111101AADDDD1100</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	Ds,@-As</div>
<div class="col_cont_3">As-2 -&gt; As, MSW of Ds -&gt; (As)</div>
<div class="col_cont_4">111101AADDDD0001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	Ds,@As</div>
<div class="col_cont_3">MSW of Ds -&gt; (As)</div>
<div class="col_cont_4">111101AADDDD0101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	Ds,@As+</div>
<div class="col_cont_3">MSW of Ds -&gt; (As), As+2 -&gt; As</div>
<div class="col_cont_4">111101AADDDD1001</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.w	Ds,@As+Is</div>
<div class="col_cont_3">MSW of DS -&gt; (As), As+Is -&gt; As</div>
<div class="col_cont_4">111101AADDDD1101</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	@-As,Ds</div>
<div class="col_cont_3">As-4 -&gt; As, (As) -&gt; Ds</div>
<div class="col_cont_4">111101AADDDD0010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	@As,Ds</div>
<div class="col_cont_3">(As) -&gt; Ds</div>
<div class="col_cont_4">111101AADDDD0110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	@As+,Ds</div>
<div class="col_cont_3">(As) -&gt; Ds, As+4 -&gt; As</div>
<div class="col_cont_4">111101AADDDD1010</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	@As+Is,Ds</div>
<div class="col_cont_3">(As) -&gt; Ds, As+Is -&gt; As</div>
<div class="col_cont_4">111101AADDDD1110</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	Ds,@-As</div>
<div class="col_cont_3">As-4 -&gt; As, Ds -&gt; (As)</div>
<div class="col_cont_4">111101AADDDD0011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	Ds,@As</div>
<div class="col_cont_3">Ds -&gt; (As)</div>
<div class="col_cont_4">111101AADDDD0111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	Ds,@As+</div>
<div class="col_cont_3">Ds -&gt; (As), As+4 -&gt; As</div>
<div class="col_cont_4">111101AADDDD1011</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">movs.l	Ds,@As+Is</div>
<div class="col_cont_3">Ds -&gt; (As), As+Is -&gt; As</div>
<div class="col_cont_4">111101AADDDD1111</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Transfers the source operand data to the destination. The transferred data is a
longword.
<br><br>

<i><b>Note</b></i><br>When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br><br>

</div></div>
<br><b>DSP ALU Arithmetic Operation Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pabs		Sx,Dz</div>
<div class="col_cont_3">If Sx &gt;= 0: Sx -&gt; Dz
If Sx &lt; 0: 0 - Sx -&gt; Dz</div>
<div class="col_cont_4">111110********** 10001000xx00zzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds absolute values. When the Sx operand is positive, the contents of the
operand are transferred to the Dz operand. If the value is negative, the value
of the Sx operand is subtracted from 0 and stored in the Dz operand.
<br><br>
The DC bit of the DSR register are updated according to the specifications of
the CS bits. The N, Z, V, and GT bits of the DSR register are updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pabs_sx (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    // positive value
    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;
    carry_bit = 0;
    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  }
  else
  {
    // negative value
    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;
    borrow_bit = 1;
    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  }

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    #include "fixed_pt_plus_dc_bit.c"
  }
  else
  {
    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
    #include "fixed_pt_minus_dc_bit.c"
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pabs		Sy,Dz</div>
<div class="col_cont_3">If Sy &gt;= 0: Sy -&gt; Dz
If Sy &lt; 0: 0 - Sy -&gt; Dz</div>
<div class="col_cont_4">111110********** 1010100000yyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds absolute values. When the Sy operand is positive, the contents of the
operand are transferred to the Dz operand. If the value is negative, the value
of the Sy operand is subtracted from 0 and stored in the Dz operand.
<br><br>
The DC bit of the DSR register are updated according to the specifications of
the CS bits. The N, Z, V, and GT bits of the DSR register are updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pabs_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    // positive value
    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;
    carry_bit = 0;
    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  }
  else
  {
    // negative value
    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;
    borrow_bit = 1;
    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  }

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    #include "fixed_pt_plus_dc_bit.c"
  }
  else
  {
    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
    #include "fixed_pt_minus_dc_bit.c"
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">padd		Sx,Sy,Dz</div>
<div class="col_cont_3">Sx + Sy -&gt; Dz</div>
<div class="col_cont_4">111110********** 10110001xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds the contents of the Sx and Sy operands and stores the result in the Dz
operand.  The DC bit of the DSR register is updated according to the
specifications for the CS bits. The N, Z, V, and GT bits of the DSR register
are also updated.
<br><br>

<i><b>Note</b></i><br>The DC bit is updated depending on the state of the CS [2:0] bit immediately
before the operation.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void padd (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PADD   X0,Y0,A0   NOPX   NOPY    ! Before execution: X0 = 0x22222222, Y0 = 0x33333333, A0 = 0x123456789A
                                 ! After execution:  X0 = 0x22222222, Y0 = 0x33333333, A0 = 0x0055555555
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct padd	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 1: Sx + Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10110010xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally adds the contents of the Sx and Sy operands and stores the result
in the Dz operand.  The instruction is executed of the DC bit is set to 1.
Otherwise no operation is performed.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void padd_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG [ex2_dz_no] = DSP_ALU_DST;
    if(ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no==1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf padd	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 0: Sx + Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10110011xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally adds the contents of the Sx and Sy operands and stores the result
in the Dz operand.  The instruction is executed of the DC bit is set to 0.
Otherwise no operation is performed.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void padd_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG [ex2_dz_no] = DSP_ALU_DST;
    if(ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no==1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">padd		Sx,Sy,Du
pmuls		Se,Sf,Dg</div>
<div class="col_cont_3">Sx + Sy -&gt; Du
MSW of Se * MSW of Sf -&gt; Dg</div>
<div class="col_cont_4">111110********** 0111eeffxxyygguu</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds the contents of the Sx and Sy operands and stores the result in the Du
operand. The contents of the top word of the Se and Sf operands are multiplied
as signed and the result stored in the Dg operand. These two processes are
executed simultaneously in parallel.
<br><br>
The DC bit of the DSR register is updated according to the results of the ALU
operation and the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated according to the results of the ALU operation.
<br><br>

<i><b>Note</b></i><br>Since the PMULS is fixed decimal point multiplication, the operation result is
different from that of MULS even though the source data is the same.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void padd_pmuls (void)
{
  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  switch (EX2_DU)
  {
  case 0x0:
    X0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x1:
    Y0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x2:
    A0 = DSP_ALU_DST;
    A0G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G = A0G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x3:
    A1 = DSP_ALU_DST;
    A1G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G = A1G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);
    break;
  }

  #include "fixed_pt_plus_dc_bit.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PADD  A0,M0,A0  PMULS X0,YO,MO  NOPX  NOPY
                ! Before execution:  X0 = 0x00020000, Y0 = 0x00030000, M0 = 0x22222222, A0 = 0x0055555555
                ! After execution: X0 = 0x00020000, Y0 = 0x00030000, M0 = 0x0000000C, A0 = 0x0077777777
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">paddc		Sx,Sy,Dz</div>
<div class="col_cont_3">Sx + Sy + DC -&gt; Dz</div>
<div class="col_cont_4">111110********** 10110000xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds the contents of the Sx and Sy operands to the DC bit and stores the result
in the Dz operand. The DC bit of the DSR register is updated as the carry flag.
The N, Z, V, and GT bits of the DSR register are also updated.

<br><br>

<i><b>Note</b></i><br>The DC bit is updated as the carry flag after execution of the PADDC instruction
regardless of the CS bits.
<br><br>
CS[2:0] = ***: Always operate as Carry or Borrow mode, regardless of the status
of the DC bit.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void paddc (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2 + DSPDCBIT;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_dc_always_carry.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PADDC X0,Y0,M0  NOPX  NOPY   ! Before execution: X0 = 0xB3333333, Y0 = 0x55555555 M0 = 0x12345678, DC = 0
                             ! After execution: X0 = 0xB3333333, Y0 = 0x55555555 M0 = 0x08888888, DC = 1


PADDC X0,Y0,M0  NOPX  NOPY   ! Before execution: X0 = 0x33333333, Y0 = 0x55555555 M0 = 0x12345678, DC = 1
                             ! After execution: X0 = 0x33333333, Y0 = 0x55555555 M0 = 0x88888889, DC = 0
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pclr		Dz</div>
<div class="col_cont_3">0x00000000 -&gt; Dz</div>
<div class="col_cont_4">111110********** 100011010000zzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Clears the Dz operand.  The DC bit of the DSR register is updated according to
the specifications for the CS bits. The Z bit of the DSR register is set to 1.
The N, V, and GT bits are cleared to 0.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pclr (void)
{
  DSP_REG[ex2_dz_no] = 0x0;

  if (ex2_dz_no == 0)
    A0G = 0x0;
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0;
  negative_bit = 0;
  zero_bit = 1;
  overflow_bit = 0;

  #include "fixed_pt_plus_dc_bit.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PCLR  A0  NOPX  NOPY   ! Before execution: A0 = 0xFF87654321
                       ! After execution: A0 = 0x0000000000
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pclr	Dz</div>
<div class="col_cont_3">If DC = 1: 0x00000000 -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 100011100000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally clears the Dz operand.  The instruction is executed when the DC
bit is set to 1.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pclr_dct (void)
{
  if (DC == 1)
    DSP_REG[ex2_dz_no] = 0x0;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pclr	Dz</div>
<div class="col_cont_3">If DC = 0: 0x00000000 -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 100011110000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally clears the Dz operand.  The instruction is executed when the DC
bit is set to 0.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pclr_dcf (void)
{
  if (DC == 0)
    DSP_REG[ex2_dz_no] = 0x0;
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pcmp		Sx,Sy</div>
<div class="col_cont_3">Sx - Sy</div>
<div class="col_cont_4">111110********** 10000100xxyy0000</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of the Sy operand from the Sx operand. The DC bit of the
DSR register is updated according to the specifications for the CS bits.
The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pcmp (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);

  borrow_bit = ! carry_bit;

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  
  negative_bit = DSP_ALU_DSTG_BIT7;
  zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_minus_dc_bit.c"

}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PCMP  X0,Y0  NOPX  NOPY  ! Before execution: X0 = 0x22222222, Y0 = 0x33333333
                         ! After execution: X0 = 0x22222222, Y0 = 0x33333333
                         !                  N = 1, Z = 0, V = 0, GT = 0
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pcopy		Sx,Dz</div>
<div class="col_cont_3">Sx -&gt; Dz</div>
<div class="col_cont_4">111110********** 11011001xx00zzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the Sx operand in the Dz operand.  The DC bit of the DSR register
is updated according to the specifications for the CS bits. The N, Z, V, and GT
bits are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pcopy_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}

</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pcopy		Sy,Dz</div>
<div class="col_cont_3">Sy -&gt; Dz</div>
<div class="col_cont_4">111110********** 1111100100yyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the Sy operand in the Dz operand.  The DC bit of the DSR register
is updated according to the specifications for the CS bits. The N, Z, V, and GT
bits are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pcopy_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PCOPY  X0,A0  NOPX  NOPY  ! Before execution: X0 = 0x55555555, A0 = 0xFFFFFFFF
                          ! After execution: X0 = 0x55555555, A0 = 0x0055555555
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pcopy	Sx,Dz</div>
<div class="col_cont_3">If DC = 1: Sx -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 11011010xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Sx operand in the Dz operand.  The instruction
is executed if the DC bit is set to 1.  The DC, N, Z, V, and GT bits are not
updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pcopy_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pcopy	Sy,Dz</div>
<div class="col_cont_3">If DC = 1: Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1111101000yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Sy operand in the Dz operand.  The instruction
is executed if the DC bit is set to 1.  The DC, N, Z, V, and GT bits are not
updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pcopy_sy_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pcopy	Sx,Dz</div>
<div class="col_cont_3">If DC = 0: Sx -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 11011011xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Sx operand in the Dz operand.  The instruction
is executed if the DC bit is set to 0.  The DC, N, Z, V, and GT bits are not
updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pcopy_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pcopy	Sy,Dz</div>
<div class="col_cont_3">If DC = 0: Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1111101100yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Sy operand in the Dz operand.  The instruction
is executed if the DC bit is set to 0.  The DC, N, Z, V, and GT bits are not
updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pcopy_sy_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pneg		Sx,Dz</div>
<div class="col_cont_3">0 - Sx -&gt; Dz</div>
<div class="col_cont_4">111110********** 11001001xx00zzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Reverses the sign. Subtracts the Sx operand from 0 and stores the result in
the Dz operand.  The DC bit of the DSR register is updated according to the
specifications for the CS bits. The N, Z, V, and GT bits of the DSR register
are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pneg_sx (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pneg		Sy,Dz</div>
<div class="col_cont_3">0 - Sy -&gt; Dz</div>
<div class="col_cont_4">111110********** 1110100100yyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Reverses the sign. Subtracts the Sy operand from 0 and stores the result in
the Dz operand.  The DC bit of the DSR register is updated according to the
specifications for the CS bits. The N, Z, V, and GT bits of the DSR register
are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pneg_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pneg	Sx,Dz</div>
<div class="col_cont_3">If DC = 1: 0 - Sx -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 11001010xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 1.  Subtracts the Sx operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pneg_sx_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pneg	Sy,Dz</div>
<div class="col_cont_3">If DC = 1: 0 - Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1110101000yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 1.  Subtracts the Sy operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pneg_sy_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pneg	Sx,Dz</div>
<div class="col_cont_3">If DC = 0: 0 - Sx -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 11001011xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 0.  Subtracts the Sx operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pneg_sx_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pneg	Sy,Dz</div>
<div class="col_cont_3">If DC = 0: 0 - Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1110101100yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 0.  Subtracts the Sy operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pneg_sy_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">psub		Sx,Sy,Dz</div>
<div class="col_cont_3">Sx - Sy -&gt; Dz</div>
<div class="col_cont_4">111110********** 10100001xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of the Sy operand from the Sx operand and stores the
result in the Dz operand.  The DC bit of the DSR register is updated according
to the specifications for the CS bits. The N, Z, V, and GT bits of the DSR
register are updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psub (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PSUB  X0,Y0,A0  NOPX  NOPY  ! Before execution: X0 = 0x55555555, Y0 = 0x33333333, A0 = 0x123456789A
                            ! After execution: X0 = 0x55555555, Y0 = 0x33333333, A0 = 0x0022222222
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct psub	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 1: Sx - Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10100010xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally subtracts the contents of the Sy operand from the Sx operand and
stores the result in the Dz operand.  The instruction is executed if the DC bit
is set to 1.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psub_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf psub 	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 0: Sx - Sy -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10100011xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally subtracts the contents of the Sy operand from the Sx operand and
stores the result in the Dz operand.  The instruction is executed if the DC bit
is set to 0.  The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psub_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">psub		Sx,Sy,Du
pmuls		Se,Sf,Dg</div>
<div class="col_cont_3">Sx - Sy -&gt; Du
MSW of Se * MSW of Sf -&gt; Dg</div>
<div class="col_cont_4">111110********** 0110eeffxxyygguu</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of the Sy operand from the Sx operand and stores the
result in the Du operand. The contents of the top word of the Se and Sf operands
are multiplied as signed and the result stored in the Dg operand. These two
processes are executed simultaneously in parallel.
<br><br>
The DC bit of the DSR register is updated according to the results of the ALU
operation and the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated according to the results of the ALU operation.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psub_pmuls (void)
{
  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  switch (EX2_DU)
  {
  case 0x0:
    X0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DST_MSB;
    zero_bit = (DSP_ALU_DST == 0);
    break;

  case 0x1:
    Y0  = DSP_ALU_DST;
    negative_bit = DSP_ALU_DST_MSB;
    zero_bit = (DSP_ALU_DST == 0);
    break;

  case 0x2:
    A0 = DSP_ALU_DST;
    A0G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G = A0G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x3:
    A1 = DSP_ALU_DST;
    A1G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G = A1G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);
    break;
  }

  #include "fixed_pt_minus_dc_bit.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PSUB  A0,M0,A0  PMULS X0,Y0,M0  NOPX  NOPY
            ! Before execution: X0 = 0x00020000, Y0 = 0xFFFE0000, M0 = 0x33333333, A0 = 0x0022222222
            ! After execution: X0 = 0x00020000, Y0 = 0xFFFE0000, M0 = 0xFFFFFFF8, A0 = 0x55555555
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">psubc		Sx,Sy,Dz</div>
<div class="col_cont_3">Sx - Sy - DC -&gt; Dz</div>
<div class="col_cont_4">111110********** 10100000xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts the contents of the Sy operand and the DC bit from the Sx operand and
stores the result in the Dz operand. The DC bit of the DSR register is updated
as the borrow flag. The N, Z, V, and GT bits of the DSR register are also
updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psubc (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2 - DSPDCBIT;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_dc_always_borrow.c"
}
</p></pre>

<i><b>Example</b></i><br><pre><p class="precode">PSUBC X0,Y0,M0  NOPX  NOPY  ! Before execution: X0 = 0x33333333, Y0 = 0x55555555 M0 = 0x0012345678, DC = 0
                            ! After execution: X0 = 0x33333333, Y0 = 0x55555555 M0 = 0xFFDDDDDDDE, DC = 1

PSUBC X0,Y0,M0  NOPX  NOPY  ! Before execution: X0 = 0x33333333, Y0 = 0x55555555 M0 = 0x0012345678, DC = 1
                            ! After execution: X0 = 0x33333333, Y0 = 0x55555555 M0 = 0xFFDDDDDDDD, DC = 1
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pdec		Sx,Dz</div>
<div class="col_cont_3">MSW of Sx - 1 -&gt; MSW of Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10001001xx00zzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts 1 from the top word of the Sx operand, stores the result in the upper
word of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Note</b></i><br>The bottom word of the destination register is ignored when the DC bit is
updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdec_sx (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_minus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pdec		Sy,Dz</div>
<div class="col_cont_3">MSW of Sy - 1 -&gt; MSW of Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 1010100100yyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Subtracts 1 from the top word of the Sy operand, stores the result in the upper
word of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Note</b></i><br>The bottom word of the destination register is ignored when the DC bit is
updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdec_sy (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_minus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pdec	Sx,Dz</div>
<div class="col_cont_3">If DC = 1: MSW of Sx - 1 -&gt; MSW of DZ, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10001010xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally subtracts 1 from the top word of the Sx operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdec_sx_dct (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pdec	Sy,Dz</div>
<div class="col_cont_3">If DC = 1: MSW of Sy - 1 -&gt; MSW of DZ, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1010101000yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally subtracts 1 from the top word of the Sy operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdec_sy_dct (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pdec	Sx,Dz</div>
<div class="col_cont_3">If DC = 0: MSW of Sx - 1 -&gt; MSW of DZ, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10001011xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally subtracts 1 from the top word of the Sx operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdec_sx_dcf (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pdec	Sy,Dz</div>
<div class="col_cont_3">If DC = 0: MSW of Sy - 1 -&gt; MSW of DZ, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1010101100yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally subtracts 1 from the top word of the Sy operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdec_sy_dcf (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pinc		Sx,Dz</div>
<div class="col_cont_3">MSW of Sy + 1 -&gt; MSW of Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10011001xx00zzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds 1 to the top word of the Sx operand, stores the result in the upper word
of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pinc_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pinc		Sy,Dz</div>
<div class="col_cont_3">MSW of Sy + 1 -&gt; MSW of Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 1011100100yyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Adds 1 to the top word of the Sy operand, stores the result in the upper word
of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pinc_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pinc	Sx,Dz</div>
<div class="col_cont_3">If DC = 1: MSW of Sx + 1 -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10011010xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally adds 1 to the top word of the Sx operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pinc_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pinc	Sy,Dz</div>
<div class="col_cont_3">If DC = 1: MSW of Sy + 1 -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1011101000yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally adds 1 to the top word of the Sy operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pinc_sy_dct (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pinc	Sx,Dz</div>
<div class="col_cont_3">If DC = 0: MSW of Sx + 1 -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10011011xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally adds 1 to the top word of the Sx operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pinc_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pinc	Sy,Dz</div>
<div class="col_cont_3">If DC = 0: MSW of Sy + 1 -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1011101100yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally adds 1 to the top word of the Sy operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pinc_sy_dcf (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pdmsb		Sx,Dz</div>
<div class="col_cont_3">Sx data MSB position -&gt; MSW of Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10011101xx00zzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds the first position to change in the lineup of Sx operand bits and stores
the bit position in the Dz operand.  The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of the
DSR register are also updated. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdmsb_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) &amp;&amp; (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) &amp;&amp; (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;
  overflow_bit = 0;

  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pdmsb		Sy,Dz</div>
<div class="col_cont_3">Sy data MSB position -&gt; MSW of Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 1011110100yyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Finds the first position to change in the lineup of Sy operand bits and stores
the bit position in the Dz operand.  The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of the
DSR register are also updated. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdmsb_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) &amp;&amp; (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) &amp;&amp; (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;
  overflow_bit = 0;

  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pdmsb	Sx,Dz</div>
<div class="col_cont_3">If DC = 1: Sx data MSB position -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10011110xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally finds the first position to change in the lineup of Sx operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdmsb_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) &amp;&amp; (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) &amp;&amp; (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pdmsb	Sy,Dz</div>
<div class="col_cont_3">If DC = 1: Sy data MSB position -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1011111000yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally finds the first position to change in the lineup of Sy operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdmsb_sy_dct (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) &amp;&amp; (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) &amp;&amp; (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pdmsb	Sx,Dz</div>
<div class="col_cont_3">If DC = 0: Sx data MSB position -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10011111xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally finds the first position to change in the lineup of Sx operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdmsb_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) &amp;&amp; (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) &amp;&amp; (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pdmsb	Sy,Dz</div>
<div class="col_cont_3">If DC = 0: Sy data MSB position -&gt; MSW of Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 1011111100yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally finds the first position to change in the lineup of Sy operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pdmsb_sy_dcf (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) &amp;&amp; (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) &amp;&amp; (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">prnd		Sx,Dz</div>
<div class="col_cont_3">Sx + 0x00008000 -&gt; Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10011000xx00zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Does rounding. Adds the immediate data 0x00008000 to the contents of the Sx
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of Dz with zeros.
<br><br>
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void prnd_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) &amp; MASKFFFF0000;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">prnd		Sy,Dz</div>
<div class="col_cont_3">Sy + 0x00008000 -&gt; Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 1011100000yyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Does rounding. Adds the immediate data 0x00008000 to the contents of the Sy
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of Dz with zeros.
<br><br>
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void prnd_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) &amp; MASKFFFF0000;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</p></pre>

</div></div>
<br><b>DSP ALU Logical Operation Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pand		Sx,Sy,Dz</div>
<div class="col_cont_3">Sx &amp; Sy -&gt; Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10010101xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Does an AND of the upper word of the Sx operand and the upper word of the Sy
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of the Dz operand with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed. The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated. 
<br><br>

<i><b>Note</b></i><br>The bottom word of the destination register and the guard bits are ignored when
the DC bit is updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pand (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &amp; DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pand	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 1: Sx &amp; Sy -&gt; Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10010110xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally does an AND of the upper word of the Sx operand and the upper word
of the Sy operand, stores the result in the upper word of the Dz operand, and
clears the bottom word of the Dz operand with zeros. When Dz is a register that
has guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pand_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &amp; DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no==1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pand	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 0: Sx &amp; Sy -&gt; Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10010111xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally does an AND of the upper word of the Sx operand and the upper word
of the Sy operand, stores the result in the upper word of the Dz operand, and
clears the bottom word of the Dz operand with zeros. When Dz is a register that
has guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pand_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &amp; DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no==1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">por		Sx,Sy,Dz</div>
<div class="col_cont_3">Sx | Sy -&gt; Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10110101xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Takes the OR of the top word of the Sx operand and the top word of the Sy
operand, stores the result in the top word of the Dz operand, and clears the
bottom word of Dz with zeros. When Dz is a register that has guard bits, the
guard bits are also zeroed.   The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated.
<br><br>

<i><b>Note</b></i><br>The bottom word of the destination register and the guard bits are ignored when
the DC bit is updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void por (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct por		Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 1: Sx | Sy -&gt; Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10110110xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally takes the OR of the top word of the Sx operand and the top word
of the Sy operand, stores the result in the top word of the Dz operand, and
clears the bottom word of Dz with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed.  The instruction is executed if the DC bit
is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void por_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // /*  */
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf por		Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 0: Sx | Sy -&gt; Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10110111xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally takes the OR of the top word of the Sx operand and the top word
of the Sy operand, stores the result in the top word of the Dz operand, and
clears the bottom word of Dz with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed.  The instruction is executed if the DC bit
is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void por_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // /*  */
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pxor		Sx,Sy,Dz</div>
<div class="col_cont_3">Sx ^ Sy -&gt; Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10100101xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Takes the exclusive OR of the top word of the Sx operand and the top word of the
Sy operand, stores the result in the top word of the Dz operand, and clears the
bottom word of Dz with zeros. When Dz is a register that has guard bits, the
guard bits are also zeroed.  The DC bit of the DSR register is updated according
to the specifications for the CS bits. The N, Z, V, and GT bits of the DSR
register are also updated. 
<br><br>

<i><b>Note</b></i><br>The bottom word of the destination register and the guard bits are ignored when
the DC bit is updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pxor (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pxor	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 1: Sx ^ Sy -&gt; Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10100110xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally takes the exclusive OR of the top word of the Sx operand and the
top word of the Sy operand, stores the result in the top word of the Dz operand,
and clears the bottom word of Dz with zeros. When Dz is a register that has
guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pxor_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pxor	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 0: Sx ^ Sy -&gt; Dz, clear LSW of Dz
Else: nop</div>
<div class="col_cont_4">111110********** 10100111xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally takes the exclusive OR of the top word of the Sx operand and the
top word of the Sy operand, stores the result in the top word of the Dz operand,
and clears the bottom word of Dz with zeros. When Dz is a register that has
guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pxor_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<br><b>DSP Fixed Decimal Point Multiplication Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pmuls	Se,Sf,Dg</div>
<div class="col_cont_3">MSW of Se * MSW of Sf -&gt; Dg</div>
<div class="col_cont_4">111110********** 0100eeff0000gg00</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>The contents of the top word of the Se and Sf operands are multiplied as signed
and the result stored in the Dg operand. The DC, N, Z, V, and GT bits of the
DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Since PMULS is fixed decimal point multiplication, the operation result is
different from that of MULS even though the source data is the same.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pmuls (void)
{
  switch (ee)  // Se Operand selection bit (ee)
  {
  case 0x0:
    DSP_M_SRC1 = X0;
    break;
  
  case 0x1:
    DSP_M_SRC1 = X1;
    break;

  case 0x2:
    DSP_M_SRC1 = Y0;
    break;

  case 0x3:
    DSP_M_SRC1 = A1;
    break;
  }

  switch (ff)  // Sf Operand selection bit (ff)
  {
  case 0x0:
    DSP_M_SRC2 = Y0;
    break;

  case 0x1:
    DSP_M_SRC2 = Y1;
    break;

  case 0x2:
    DSP_M_SRC2 = X0;
    break;

  case 0x3:
    DSP_M_SRC2 = A1;
    break;
  }

  if ((SBIT == 1) &amp;&amp; (DSP_M_SRC1 == 0x8000) &amp;&amp; (DSP_M_SRC2 == 0x8000))
    DSP_M_DST = 0x7FFFFFFF;  // overflow protection
  else
    DSP_M_DST= ((long)(short)DSP_M_SRC1 * (long)(short)DSP_M_SRC2) &lt;&lt; 1;

  if (DSP_M_DST_MSB)
    DSP_M_DSTG_LSB8 = 0xFF;
  else
    DSP_M_DSTG_LSB8 = 0x0;

  switch (gg)  // Dg Operand selection bit (gg)
  {
  case 0x0:
    M0 = DSP_M_DST;
    break;

  case 0x1:
    M1 = DSP_M_DST;
    break;

  case 0x2:
    A0 = DSP_M_DST;
    if (DSP_M_DSTG_LSB8 == 0x0)
      A0G=0x0;
    else
      A0G = 0xFFFFFFFF;
    break;

  case 0x3:
    A1 = DSP_M_DST;
    if (DSP_M_DSTG_LSB8 == 0x0)
      A1G = 0x0;
    else
      A1G = 0xFFFFFFFF;
    break;
  }
}
</p></pre>

</div></div>
<br><b>DSP Shift Operation Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">psha		Sx,Sy,Dz</div>
<div class="col_cont_3">If Sy &gt;= 0: Sx &lt;&lt; Sy -&gt; Dz
If Sy &lt; 0: Sx &gt;&gt; Sy -&gt; Dz</div>
<div class="col_cont_4">111110********** 10010001xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically shifts the contents of the Sx or Dz operand and stores the result
in the Dz operand. The amount of the shift is specified by the Sy operand. 
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psha (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 &amp; MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 &amp; MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 &amp; MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 &amp; MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW &amp; MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW &amp; MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) &amp; MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG &amp; MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW &amp; MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt &gt; 8) &amp;&amp; DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) &amp; MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "shift_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct psha	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 1 &amp; Sy &gt;= 0: Sx &lt;&lt; Sy -&gt; Dz
If DC = 1 &amp; Sy &lt; 0: Sx &gt;&gt; Sy -&gt; Dz
If DC = 0: nop</div>
<div class="col_cont_4">111110********** 10010010xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally arithmetically shifts the contents of the Sx operand and
stores the result in the Dz operand. The amount of the shift is specified by
the Sy operand.  When the shift amount is positive, it shifts left. When the
shift amount is negative, it shifts right.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psha_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 &amp; MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 &amp; MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 &amp; MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 &amp; MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW &amp; MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW &amp; MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) &amp; MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG &amp; MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW &amp; MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt &gt; 8) &amp;&amp; DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) &amp; MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf psha	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 0 &amp; Sy &gt;= 0: Sx &lt;&lt; Sy -&gt; Dz
If DC = 0 &amp; Sy &lt; 0: Sx &gt;&gt; Sy -&gt; Dz
If DC = 1: nop</div>
<div class="col_cont_4">111110********** 10010011xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally arithmetically shifts the contents of the Sx operand and
stores the result in the Dz operand. The amount of the shift is specified by
the Sy operand.  When the shift amount is positive, it shifts left. When the
shift amount is negative, it shifts right.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psha_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 &amp; MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 &amp; MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 &amp; MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 &amp; MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW &amp; MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW &amp; MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) &amp; MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG &amp; MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW &amp; MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt &gt; 8) &amp;&amp; DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) &amp; MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">psha		#imm,Dz</div>
<div class="col_cont_3">If imm &gt;= 0: Dz &lt;&lt; imm -&gt; Dz
If imm &lt; 0: Dz &gt;&gt; imm -&gt; Dz</div>
<div class="col_cont_4">111110********** 00000iiiiiiizzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Arithmetically shifts the contents of the Dz operand and stores the result in
the Dz operand. The amount of the shift is specified by the immediate value.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psha_imm (void)
{
  unsigned short tmp_imm;
  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];

  switch (ex2_dz_no)
  {
    case 0x0:
      DSP_ALU_SRC1G = A0G;
      break;

    case 0x1:
      DSP_ALU_SRC1G = A1G;
      break;

    default:
      if (DSP_ALU_SRC1_MSB)
        DSP_ALU_SRC1G = 0xFF;
      else
        DSP_ALU_SRC1G = 0x0;
  }

  tmp_imm = ((EX2_LW &gt;&gt; 4) &amp; MASK0000007F); // bit[10:4]

  if ((tmp_imm &amp; MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = tmp_imm &amp; MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\n", tmp_imm);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) &amp; MASK000000FF;
    carry_bit = (DSP_ALU_DSTG &amp; MASK00000001) == 0x1;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~tmp_imm &amp; MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\n", tmp_imm);
      exit ();
    }

    if ((cnt &gt; 8) &amp;&amp; DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) &amp; MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "shift_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pshl		Sx,Sy,Dz</div>
<div class="col_cont_3">If Sy &gt;= 0: Sx &lt;&lt; Sy -&gt; Dz, clear LSW of Dz
If Sy &lt; 0: Sx &gt;&gt; Sy -&gt; Dz, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 10000001xxyyzzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the top word contents of the Sx operand, stores the result in
the top word of the Dz operand, and clears the bottom word of the Dz operand
with zeros. When Dz is a register that has guard bits, the guard bits are also
zeroed. The amount of the shift is specified by the Sy operand. When the shift
amount is positive, it shifts left. When the shift amount is negative, it
shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated. 
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pshl (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 &amp; MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 &amp; MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 &amp; MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 &amp; MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW &amp; MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW &amp; MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) &amp; MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW &amp; MASK000F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) &amp; MASK0001) == 0x1;
  }

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = DSP_ALU_DST_HW == 0;
  overflow_bit = 0x0;

  #include "shift_dc_bit.c"
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct pshl	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 1 &amp; Sy &gt;= 0: Sx &lt;&lt; Sy -&gt; Dz, clear LSW of Dz
If DC = 1 &amp; Sy &lt; 0: Sx &gt;&gt; Sy -&gt; Dz, clear LSW of Dz
If DC = 0: nop</div>
<div class="col_cont_4">111110********** 10000010xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally logically shifts the top word contents of the Sx operand, stores
the result in the top word of the Dz operand, and clears the bottom word of the
Dz operand with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the Sy operand. When
the shift amount is positive, it shifts left. When the shift amount is negative,
it shifts right.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pshl_dct
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 &amp; MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 &amp; MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 &amp; MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 &amp; MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW &amp; MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW &amp; MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) &amp; MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW &amp; MASK000F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) &amp; MASK0001) == 0x1;
  }

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf pshl	Sx,Sy,Dz</div>
<div class="col_cont_3">If DC = 0 &amp; Sy &gt;= 0: Sx &lt;&lt; Sy -&gt; Dz, clear LSW of Dz
If DC = 0 &amp; Sy &lt; 0: Sx &gt;&gt; Sy -&gt; Dz, clear LSW of Dz
If DC = 1: nop</div>
<div class="col_cont_4">111110********** 10000011xxyyzzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally logically shifts the top word contents of the Sx operand, stores
the result in the top word of the Dz operand, and clears the bottom word of the
Dz operand with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the Sy operand. When
the shift amount is positive, it shifts left. When the shift amount is negative,
it shifts right.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.

<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pshl_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 &amp; MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 &amp; MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 &amp; MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 &amp; MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW &amp; MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW &amp; MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) &amp; MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW &amp; MASK000F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) &amp; MASK0001) == 0x1;
  }

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">pshl		#imm,Dz</div>
<div class="col_cont_3">If imm &gt;= 0: Dz &lt;&lt; imm -&gt; Dz, clear LSW of Dz
If imm &lt; 0: Dz &gt;&gt; imm, clear LSW of Dz</div>
<div class="col_cont_4">111110********** 00010iiiiiiizzzz</div>
<div class="col_cont_5">
Update</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Logically shifts the top word contents of the Dz operand, stores the result in
the top word of the Dz operand, and clears the bottom word of the Dz operand
with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the immediate value.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void pshl_imm (void)
{
  unsigned short tmp_imm;
  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];
  switch (ex2_dz_no)
  {
  case 0x0:
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x1:
    DSP_ALU_SRC1G = A1G;
    break;

  default:
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
  }

  tmp_imm = ((EX2_LW &gt;&gt; 4) &amp; MASK0000003F); // bit[9:4]
  if ((tmp_imm &amp; MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt; 16
    char cnt = tmp_imm &amp; MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\n", tmp_imm);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) &amp; MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~tmp_imm &amp; MASK001F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\n", tmp_imm);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) &amp; MASK0001) == 0x1;
  }

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = DSP_ALU_DST_HW == 0;
  overflow_bit = 0x0;

  #include "shift_dc_bit.c"
}
</p></pre>

</div></div>
<br><b>DSP System Control Instructions</b><br><br>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">plds		Dz,MACH</div>
<div class="col_cont_3">Dz -&gt; MACH</div>
<div class="col_cont_4">111110********** 111011010000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the Dz operand in the MACH register.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void plds_mach (void)
{
  MACH = DSP_REG[ex2_dz_no];
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">plds		Dz,MACL</div>
<div class="col_cont_3">Dz -&gt; MACL</div>
<div class="col_cont_4">111110********** 111111010000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the Dz operand in the MACL register.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void plds_macl (void)
{
  MACL = DSP_REG[ex2_dz_no];
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct plds	Dz,MACH</div>
<div class="col_cont_3">If DC = 1: Dz -&gt; MACH
Else: nop</div>
<div class="col_cont_4">111110********** 111011100000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Dz operand in the MACH register.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void plds_mach_dct (void)
{
  if (DC == 1)
    MACH = DSP_REG[ex2_dz_no];
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct plds	Dz,MACL</div>
<div class="col_cont_3">If DC = 1: Dz -&gt; MACL
Else: nop</div>
<div class="col_cont_4">111110********** 111111100000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Dz operand in the MACL register.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void plds_macl_dct (void)
{
  if (DC == 1)
    MACL = DSP_REG[ex2_dz_no];
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf plds	Dz,MACH</div>
<div class="col_cont_3">If DC = 0: Dz -&gt; MACH
Else: nop</div>
<div class="col_cont_4">111110********** 111011110000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Dz operand in the MACH register.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void plds_mach_dcf (void)
{
  if (DC == 0)
    MACH = DSP_REG[ex2_dz_no];
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf plds	Dz,MACL</div>
<div class="col_cont_3">If DC = 0: Dz -&gt; MACL
Else: nop</div>
<div class="col_cont_4">111110********** 111111110000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the Dz operand in the MACL register.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void plds_macl_dcf (void)
{
  if (DC == 0)
    MACL = DSP_REG[ex2_dz_no];
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">psts		MACH,Dz</div>
<div class="col_cont_3">MACH -&gt; Dz</div>
<div class="col_cont_4">111110********** 110011010000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the contents of the MACH register in the Dz operand. 
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psts_mach (void)
{
  DSP_REG[ex2_dz_no] = MACH;
  if (ex2_dz_no == 0)
  {
    A0G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G |= MASKFFFFFF00;
  }
  else if (ex2_dz_no == 1)
  {
    A1G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G |= MASKFFFFFF00;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">psts		MACL,Dz</div>
<div class="col_cont_3">MACL -&gt; Dz</div>
<div class="col_cont_4">111110********** 110111010000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Stores the contents of the MACL register in the Dz operand. 
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psts_macl (void)
{
  DSP_REG[ex2_dz_no] = MACL;
  if (ex2_dz_no == 0)
  {
    A0G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G |= MASKFFFFFF00;
  }
  else if (ex2_dz_no == 1)
  {
    A1G = DSP_ALU_DSTG &amp; MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G |= MASKFFFFFF00;
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct psts	MACH,Dz</div>
<div class="col_cont_3">If DC = 1: MACH -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 110011100000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the contents of the MACH register in the Dz operand.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psts_mach_dct (void)
{
  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = MACH;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dct psts	MACL,Dz</div>
<div class="col_cont_3">If DC = 1: MACL -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 110111100000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the contents of the MACL register in the Dz operand.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psts_macl_dct (void)
{
  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = MACL;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf psts	MACH,Dz</div>
<div class="col_cont_3">If DC = 0: MACH -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 110011110000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the contents of the MACH register in the Dz operand.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psts_mach_dcf (void)
{
  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = MACH;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
<div class="col_cont" onmouseover="on_mouse_over(this);" onmouseout="on_mouse_out(this);" onclick="on_mouse_click(this,event);">
<div class="col_cont_1">                  
            DSP   
                  </div>
<div class="col_cont_2">dcf psts	MACL,Dz</div>
<div class="col_cont_3">If DC = 0: MACL -&gt; Dz
Else: nop</div>
<div class="col_cont_4">111110********** 110111110000zzzz</div>
<div class="col_cont_5">
</div>
<div class="col_cont_6">                  
                  
                  </div>
<div class="col_cont_7">                  
            1     
                  </div>
<div class="col_cont_8">                  
            1     
                  </div>
<div class="col_cont_note" id="note" style="display:none">
<i><b>Description</b></i><br>Conditionally stores the contents of the MACL register in the Dz operand.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br><br>

<i><b>Note</b></i><br>Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br><br>

<i><b>Operation</b></i><br><pre><p class="precode">void psts_macl_dcf (void)
{
  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = MACL;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG &amp; MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</p></pre>

</div></div>
</div>
</body></html>